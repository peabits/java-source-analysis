
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Class Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="ClassLoader.html" />
    
    
    <link rel="prev" href="Package.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../../">
            
                <a href="../../../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../../java.html">
            
                <a href="../../java.html">
            
                    
                    java
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../lang.html">
            
                <a href="../lang.html">
            
                    
                    lang
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1.1" data-path="annotation.html">
            
                <a href="annotation.html">
            
                    
                    annotation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.2" data-path="instrument.html">
            
                <a href="instrument.html">
            
                    
                    instrument
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.3" data-path="invoke.html">
            
                <a href="invoke.html">
            
                    
                    invoke
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.4" data-path="management.html">
            
                <a href="management.html">
            
                    
                    mangement
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.5" data-path="ref.html">
            
                <a href="ref.html">
            
                    
                    ref
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.6" data-path="reflect.html">
            
                <a href="reflect.html">
            
                    
                    reflect
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.7" data-path="Object.html">
            
                <a href="Object.html">
            
                    
                    Object
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.8" data-path="Number.html">
            
                <a href="Number.html">
            
                    
                    Number
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.9" data-path="Boolean.html">
            
                <a href="Boolean.html">
            
                    
                    Boolean
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.10" data-path="Character.html">
            
                <a href="Character.html">
            
                    
                    Character
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.11" data-path="Byte.html">
            
                <a href="Byte.html">
            
                    
                    Byte
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.12" data-path="Short.html">
            
                <a href="Short.html">
            
                    
                    Short
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.13" data-path="Integer.html">
            
                <a href="Integer.html">
            
                    
                    Integer
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.14" data-path="Long.html">
            
                <a href="Long.html">
            
                    
                    Long
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.15" data-path="Float.html">
            
                <a href="Float.html">
            
                    
                    Float
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.16" data-path="Double.html">
            
                <a href="Double.html">
            
                    
                    Double
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.17" data-path="Enum.html">
            
                <a href="Enum.html">
            
                    
                    Enum
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.18" data-path="Void.html">
            
                <a href="Void.html">
            
                    
                    Void
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.19" data-path="String.html">
            
                <a href="String.html">
            
                    
                    String
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.20" data-path="AbstractStringBuilder.html">
            
                <a href="AbstractStringBuilder.html">
            
                    
                    AbstractStringBuilder
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.21" data-path="StringBuffer.html">
            
                <a href="StringBuffer.html">
            
                    
                    StringBuffer
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.22" data-path="StringBuilder.html">
            
                <a href="StringBuilder.html">
            
                    
                    StringBuilder
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.23" data-path="Math.html">
            
                <a href="Math.html">
            
                    
                    Math
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.24" data-path="StrictMath.html">
            
                <a href="StrictMath.html">
            
                    
                    StrictMath
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.25" data-path="System.html">
            
                <a href="System.html">
            
                    
                    System
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.26" data-path="Process.html">
            
                <a href="Process.html">
            
                    
                    Process
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.27" data-path="Thread.html">
            
                <a href="Thread.html">
            
                    
                    Thread
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.28" data-path="Runtime.html">
            
                <a href="Runtime.html">
            
                    
                    Runtime
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.29" data-path="Compiler.html">
            
                <a href="Compiler.html">
            
                    
                    Compiler
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.30" data-path="Package.html">
            
                <a href="Package.html">
            
                    
                    Package
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.2.1.31" data-path="Class.html">
            
                <a href="Class.html">
            
                    
                    Class
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.32" data-path="ClassLoader.html">
            
                <a href="ClassLoader.html">
            
                    
                    ClassLoader
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.33" data-path="Throwable.html">
            
                <a href="Throwable.html">
            
                    
                    Throwable
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.34" data-path="Error.html">
            
                <a href="Error.html">
            
                    
                    Error
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.35" data-path="Exception.html">
            
                <a href="Exception.html">
            
                    
                    Exception
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../util.html">
            
                <a href="../util.html">
            
                    
                    util
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../math.html">
            
                <a href="../math.html">
            
                    
                    math
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="../io.html">
            
                <a href="../io.html">
            
                    
                    io
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="../nio.html">
            
                <a href="../nio.html">
            
                    
                    nio
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="../net.html">
            
                <a href="../net.html">
            
                    
                    net
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7" data-path="../sql.html">
            
                <a href="../sql.html">
            
                    
                    sql
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8" data-path="../time.html">
            
                <a href="../time.html">
            
                    
                    time
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.9" data-path="../text.html">
            
                <a href="../text.html">
            
                    
                    text
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.10" data-path="../beans.html">
            
                <a href="../beans.html">
            
                    
                    beans
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.11" data-path="../rmi.html">
            
                <a href="../rmi.html">
            
                    
                    rmi
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.12" data-path="../security.html">
            
                <a href="../security.html">
            
                    
                    security
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.13" data-path="../applet.html">
            
                <a href="../applet.html">
            
                    
                    applet
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.14" data-path="../awt.html">
            
                <a href="../awt.html">
            
                    
                    awt
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../../javax.html">
            
                <a href="../../javax.html">
            
                    
                    javax
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../../.." >Class</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="public-final-class-javalangclass">public final class java.lang.Class</h1>
<p><a href="#source-analysis">source analysis</a></p>
<p><a href="#source-code">source code</a></p>
<h2 id="source-analysis">source analysis</h2>
<h2 id="source-code">source code</h2>
<pre><code class="lang-java"><span class="hljs-comment">/*
 * Copyright (c) 1994, 2014, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */</span>

<span class="hljs-keyword">package</span> java.lang;

<span class="hljs-keyword">import</span> java.lang.reflect.AnnotatedElement;
<span class="hljs-keyword">import</span> java.lang.reflect.Array;
<span class="hljs-keyword">import</span> java.lang.reflect.GenericArrayType;
<span class="hljs-keyword">import</span> java.lang.reflect.GenericDeclaration;
<span class="hljs-keyword">import</span> java.lang.reflect.Member;
<span class="hljs-keyword">import</span> java.lang.reflect.Field;
<span class="hljs-keyword">import</span> java.lang.reflect.Executable;
<span class="hljs-keyword">import</span> java.lang.reflect.Method;
<span class="hljs-keyword">import</span> java.lang.reflect.Constructor;
<span class="hljs-keyword">import</span> java.lang.reflect.Modifier;
<span class="hljs-keyword">import</span> java.lang.reflect.Type;
<span class="hljs-keyword">import</span> java.lang.reflect.TypeVariable;
<span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;
<span class="hljs-keyword">import</span> java.lang.reflect.AnnotatedType;
<span class="hljs-keyword">import</span> java.lang.ref.SoftReference;
<span class="hljs-keyword">import</span> java.io.InputStream;
<span class="hljs-keyword">import</span> java.io.ObjectStreamField;
<span class="hljs-keyword">import</span> java.security.AccessController;
<span class="hljs-keyword">import</span> java.security.PrivilegedAction;
<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Arrays;
<span class="hljs-keyword">import</span> java.util.Collection;
<span class="hljs-keyword">import</span> java.util.HashSet;
<span class="hljs-keyword">import</span> java.util.LinkedHashMap;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.Set;
<span class="hljs-keyword">import</span> java.util.Map;
<span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.Objects;
<span class="hljs-keyword">import</span> sun.misc.Unsafe;
<span class="hljs-keyword">import</span> sun.reflect.CallerSensitive;
<span class="hljs-keyword">import</span> sun.reflect.ConstantPool;
<span class="hljs-keyword">import</span> sun.reflect.Reflection;
<span class="hljs-keyword">import</span> sun.reflect.ReflectionFactory;
<span class="hljs-keyword">import</span> sun.reflect.generics.factory.CoreReflectionFactory;
<span class="hljs-keyword">import</span> sun.reflect.generics.factory.GenericsFactory;
<span class="hljs-keyword">import</span> sun.reflect.generics.repository.ClassRepository;
<span class="hljs-keyword">import</span> sun.reflect.generics.repository.MethodRepository;
<span class="hljs-keyword">import</span> sun.reflect.generics.repository.ConstructorRepository;
<span class="hljs-keyword">import</span> sun.reflect.generics.scope.ClassScope;
<span class="hljs-keyword">import</span> sun.security.util.SecurityConstants;
<span class="hljs-keyword">import</span> java.lang.annotation.Annotation;
<span class="hljs-keyword">import</span> java.lang.reflect.Proxy;
<span class="hljs-keyword">import</span> sun.reflect.annotation.*;
<span class="hljs-keyword">import</span> sun.reflect.misc.ReflectUtil;

<span class="hljs-comment">/**
 * Instances of the class {<span class="hljs-doctag">@code</span> Class} represent classes and
 * interfaces in a running Java application.  An enum is a kind of
 * class and an annotation is a kind of interface.  Every array also
 * belongs to a class that is reflected as a {<span class="hljs-doctag">@code</span> Class} object
 * that is shared by all arrays with the same element type and number
 * of dimensions.  The primitive Java types ({<span class="hljs-doctag">@code</span> boolean},
 * {<span class="hljs-doctag">@code</span> byte}, {<span class="hljs-doctag">@code</span> char}, {<span class="hljs-doctag">@code</span> short},
 * {<span class="hljs-doctag">@code</span> int}, {<span class="hljs-doctag">@code</span> long}, {<span class="hljs-doctag">@code</span> float}, and
 * {<span class="hljs-doctag">@code</span> double}), and the keyword {<span class="hljs-doctag">@code</span> void} are also
 * represented as {<span class="hljs-doctag">@code</span> Class} objects.
 *
 * &lt;p&gt; {<span class="hljs-doctag">@code</span> Class} has no public constructor. Instead {<span class="hljs-doctag">@code</span> Class}
 * objects are constructed automatically by the Java Virtual Machine as classes
 * are loaded and by calls to the {<span class="hljs-doctag">@code</span> defineClass} method in the class
 * loader.
 *
 * &lt;p&gt; The following example uses a {<span class="hljs-doctag">@code</span> Class} object to print the
 * class name of an object:
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 *     void printClassName(Object obj) {
 *         System.out.println(&quot;The class of &quot; + obj +
 *                            &quot; is &quot; + obj.getClass().getName());
 *     }
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt; It is also possible to get the {<span class="hljs-doctag">@code</span> Class} object for a named
 * type (or for void) using a class literal.  See Section 15.8.2 of
 * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
 * For example:
 *
 * &lt;blockquote&gt;
 *     {<span class="hljs-doctag">@code</span> System.out.println(&quot;The name of class Foo is: &quot;+Foo.class.getName());}
 * &lt;/blockquote&gt;
 *
 * <span class="hljs-doctag">@param</span> &lt;T&gt; the type of the class modeled by this {<span class="hljs-doctag">@code</span> Class}
 * object.  For example, the type of {<span class="hljs-doctag">@code</span> String.class} is {<span class="hljs-doctag">@code</span>
 * Class&lt;String&gt;}.  Use {<span class="hljs-doctag">@code</span> Class&lt;?&gt;} if the class being modeled is
 * unknown.
 *
 * <span class="hljs-doctag">@author</span>  unascribed
 * <span class="hljs-doctag">@see</span>     java.lang.ClassLoader#defineClass(byte[], int, int)
 * <span class="hljs-doctag">@since</span>   JDK1.0
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Class</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>,
                              <span class="hljs-title">GenericDeclaration</span>,
                              <span class="hljs-title">Type</span>,
                              <span class="hljs-title">AnnotatedElement</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ANNOTATION= <span class="hljs-number">0x00002000</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ENUM      = <span class="hljs-number">0x00004000</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SYNTHETIC = <span class="hljs-number">0x00001000</span>;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerNatives</span><span class="hljs-params">()</span></span>;
    <span class="hljs-keyword">static</span> {
        registerNatives();
    }

    <span class="hljs-comment">/*
     * Private constructor. Only the Java Virtual Machine creates Class objects.
     * This constructor is not used and prevents the default constructor being
     * generated.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Class</span><span class="hljs-params">(ClassLoader loader)</span> </span>{
        <span class="hljs-comment">// Initialize final field for classLoader.  The initialization value of non-null</span>
        <span class="hljs-comment">// prevents future JIT optimizations from assuming this final field is null.</span>
        classLoader = loader;
    }

    <span class="hljs-comment">/**
     * Converts the object to a string. The string representation is the
     * string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the
     * fully qualified name of the class in the format returned by
     * {<span class="hljs-doctag">@code</span> getName}.  If this {<span class="hljs-doctag">@code</span> Class} object represents a
     * primitive type, this method returns the name of the primitive type.  If
     * this {<span class="hljs-doctag">@code</span> Class} object represents void this method returns
     * &quot;void&quot;.
     *
     * <span class="hljs-doctag">@return</span> a string representation of this class object.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> (isInterface() ? <span class="hljs-string">&quot;interface &quot;</span> : (isPrimitive() ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-string">&quot;class &quot;</span>))
            + getName();
    }

    <span class="hljs-comment">/**
     * Returns a string describing this {<span class="hljs-doctag">@code</span> Class}, including
     * information about modifiers and type parameters.
     *
     * The string is formatted as a list of type modifiers, if any,
     * followed by the kind of type (empty string for primitive types
     * and {<span class="hljs-doctag">@code</span> class}, {<span class="hljs-doctag">@code</span> enum}, {<span class="hljs-doctag">@code</span> interface}, or
     * &lt;code&gt;&amp;#64;&lt;/code&gt;{<span class="hljs-doctag">@code</span> interface}, as appropriate), followed
     * by the type&apos;s name, followed by an angle-bracketed
     * comma-separated list of the type&apos;s type parameters, if any.
     *
     * A space is used to separate modifiers from one another and to
     * separate any modifiers from the kind of type. The modifiers
     * occur in canonical order. If there are no type parameters, the
     * type parameter list is elided.
     *
     * &lt;p&gt;Note that since information about the runtime representation
     * of a type is being generated, modifiers not present on the
     * originating source code or illegal on the originating source
     * code may be present.
     *
     * <span class="hljs-doctag">@return</span> a string describing this {<span class="hljs-doctag">@code</span> Class}, including
     * information about modifiers and type parameters
     *
     * <span class="hljs-doctag">@since</span> 1.8
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toGenericString</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (isPrimitive()) {
            <span class="hljs-keyword">return</span> toString();
        } <span class="hljs-keyword">else</span> {
            StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();

            <span class="hljs-comment">// Class modifiers are a superset of interface modifiers</span>
            <span class="hljs-keyword">int</span> modifiers = getModifiers() &amp; Modifier.classModifiers();
            <span class="hljs-keyword">if</span> (modifiers != <span class="hljs-number">0</span>) {
                sb.append(Modifier.toString(modifiers));
                sb.append(<span class="hljs-string">&apos; &apos;</span>);
            }

            <span class="hljs-keyword">if</span> (isAnnotation()) {
                sb.append(<span class="hljs-string">&apos;@&apos;</span>);
            }
            <span class="hljs-keyword">if</span> (isInterface()) { <span class="hljs-comment">// Note: all annotation types are interfaces</span>
                sb.append(<span class="hljs-string">&quot;interface&quot;</span>);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (isEnum())
                    sb.append(<span class="hljs-string">&quot;enum&quot;</span>);
                <span class="hljs-keyword">else</span>
                    sb.append(<span class="hljs-string">&quot;class&quot;</span>);
            }
            sb.append(<span class="hljs-string">&apos; &apos;</span>);
            sb.append(getName());

            TypeVariable&lt;?&gt;[] typeparms = getTypeParameters();
            <span class="hljs-keyword">if</span> (typeparms.length &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">boolean</span> first = <span class="hljs-keyword">true</span>;
                sb.append(<span class="hljs-string">&apos;&lt;&apos;</span>);
                <span class="hljs-keyword">for</span>(TypeVariable&lt;?&gt; typeparm: typeparms) {
                    <span class="hljs-keyword">if</span> (!first)
                        sb.append(<span class="hljs-string">&apos;,&apos;</span>);
                    sb.append(typeparm.getTypeName());
                    first = <span class="hljs-keyword">false</span>;
                }
                sb.append(<span class="hljs-string">&apos;&gt;&apos;</span>);
            }

            <span class="hljs-keyword">return</span> sb.toString();
        }
    }

    <span class="hljs-comment">/**
     * Returns the {<span class="hljs-doctag">@code</span> Class} object associated with the class or
     * interface with the given string name.  Invoking this method is
     * equivalent to:
     *
     * &lt;blockquote&gt;
     *  {<span class="hljs-doctag">@code</span> Class.forName(className, true, currentLoader)}
     * &lt;/blockquote&gt;
     *
     * where {<span class="hljs-doctag">@code</span> currentLoader} denotes the defining class loader of
     * the current class.
     *
     * &lt;p&gt; For example, the following code fragment returns the
     * runtime {<span class="hljs-doctag">@code</span> Class} descriptor for the class named
     * {<span class="hljs-doctag">@code</span> java.lang.Thread}:
     *
     * &lt;blockquote&gt;
     *   {<span class="hljs-doctag">@code</span> Class t = Class.forName(&quot;java.lang.Thread&quot;)}
     * &lt;/blockquote&gt;
     * &lt;p&gt;
     * A call to {<span class="hljs-doctag">@code</span> forName(&quot;X&quot;)} causes the class named
     * {<span class="hljs-doctag">@code</span> X} to be initialized.
     *
     * <span class="hljs-doctag">@param</span>      className   the fully qualified name of the desired class.
     * <span class="hljs-doctag">@return</span>     the {<span class="hljs-doctag">@code</span> Class} object for the class with the
     *             specified name.
     * <span class="hljs-doctag">@exception</span> LinkageError if the linkage fails
     * <span class="hljs-doctag">@exception</span> ExceptionInInitializerError if the initialization provoked
     *            by this method fails
     * <span class="hljs-doctag">@exception</span> ClassNotFoundException if the class cannot be located
     */</span>
    <span class="hljs-meta">@CallerSensitive</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; forName(String className)
                <span class="hljs-keyword">throws</span> ClassNotFoundException {
        Class&lt;?&gt; caller = Reflection.getCallerClass();
        <span class="hljs-keyword">return</span> forName0(className, <span class="hljs-keyword">true</span>, ClassLoader.getClassLoader(caller), caller);
    }


    <span class="hljs-comment">/**
     * Returns the {<span class="hljs-doctag">@code</span> Class} object associated with the class or
     * interface with the given string name, using the given class loader.
     * Given the fully qualified name for a class or interface (in the same
     * format returned by {<span class="hljs-doctag">@code</span> getName}) this method attempts to
     * locate, load, and link the class or interface.  The specified class
     * loader is used to load the class or interface.  If the parameter
     * {<span class="hljs-doctag">@code</span> loader} is null, the class is loaded through the bootstrap
     * class loader.  The class is initialized only if the
     * {<span class="hljs-doctag">@code</span> initialize} parameter is {<span class="hljs-doctag">@code</span> true} and if it has
     * not been initialized earlier.
     *
     * &lt;p&gt; If {<span class="hljs-doctag">@code</span> name} denotes a primitive type or void, an attempt
     * will be made to locate a user-defined class in the unnamed package whose
     * name is {<span class="hljs-doctag">@code</span> name}. Therefore, this method cannot be used to
     * obtain any of the {<span class="hljs-doctag">@code</span> Class} objects representing primitive
     * types or void.
     *
     * &lt;p&gt; If {<span class="hljs-doctag">@code</span> name} denotes an array class, the component type of
     * the array class is loaded but not initialized.
     *
     * &lt;p&gt; For example, in an instance method the expression:
     *
     * &lt;blockquote&gt;
     *  {<span class="hljs-doctag">@code</span> Class.forName(&quot;Foo&quot;)}
     * &lt;/blockquote&gt;
     *
     * is equivalent to:
     *
     * &lt;blockquote&gt;
     *  {<span class="hljs-doctag">@code</span> Class.forName(&quot;Foo&quot;, true, this.getClass().getClassLoader())}
     * &lt;/blockquote&gt;
     *
     * Note that this method throws errors related to loading, linking or
     * initializing as specified in Sections 12.2, 12.3 and 12.4 of &lt;em&gt;The
     * Java Language Specification&lt;/em&gt;.
     * Note that this method does not check whether the requested class
     * is accessible to its caller.
     *
     * &lt;p&gt; If the {<span class="hljs-doctag">@code</span> loader} is {<span class="hljs-doctag">@code</span> null}, and a security
     * manager is present, and the caller&apos;s class loader is not null, then this
     * method calls the security manager&apos;s {<span class="hljs-doctag">@code</span> checkPermission} method
     * with a {<span class="hljs-doctag">@code</span> RuntimePermission(&quot;getClassLoader&quot;)} permission to
     * ensure it&apos;s ok to access the bootstrap class loader.
     *
     * <span class="hljs-doctag">@param</span> name       fully qualified name of the desired class
     * <span class="hljs-doctag">@param</span> initialize if {<span class="hljs-doctag">@code</span> true} the class will be initialized.
     *                   See Section 12.4 of &lt;em&gt;The Java Language Specification&lt;/em&gt;.
     * <span class="hljs-doctag">@param</span> loader     class loader from which the class must be loaded
     * <span class="hljs-doctag">@return</span>           class object representing the desired class
     *
     * <span class="hljs-doctag">@exception</span> LinkageError if the linkage fails
     * <span class="hljs-doctag">@exception</span> ExceptionInInitializerError if the initialization provoked
     *            by this method fails
     * <span class="hljs-doctag">@exception</span> ClassNotFoundException if the class cannot be located by
     *            the specified class loader
     *
     * <span class="hljs-doctag">@see</span>       java.lang.Class#forName(String)
     * <span class="hljs-doctag">@see</span>       java.lang.ClassLoader
     * <span class="hljs-doctag">@since</span>     1.2
     */</span>
    <span class="hljs-meta">@CallerSensitive</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; forName(String name, <span class="hljs-keyword">boolean</span> initialize,
                                   ClassLoader loader)
        <span class="hljs-keyword">throws</span> ClassNotFoundException
    {
        Class&lt;?&gt; caller = <span class="hljs-keyword">null</span>;
        SecurityManager sm = System.getSecurityManager();
        <span class="hljs-keyword">if</span> (sm != <span class="hljs-keyword">null</span>) {
            <span class="hljs-comment">// Reflective call to get caller class is only needed if a security manager</span>
            <span class="hljs-comment">// is present.  Avoid the overhead of making this call otherwise.</span>
            caller = Reflection.getCallerClass();
            <span class="hljs-keyword">if</span> (sun.misc.VM.isSystemDomainLoader(loader)) {
                ClassLoader ccl = ClassLoader.getClassLoader(caller);
                <span class="hljs-keyword">if</span> (!sun.misc.VM.isSystemDomainLoader(ccl)) {
                    sm.checkPermission(
                        SecurityConstants.GET_CLASSLOADER_PERMISSION);
                }
            }
        }
        <span class="hljs-keyword">return</span> forName0(name, initialize, loader, caller);
    }

    <span class="hljs-comment">/** Called after security check for system loader access checks have been made. */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; forName0(String name, <span class="hljs-keyword">boolean</span> initialize,
                                            ClassLoader loader,
                                            Class&lt;?&gt; caller)
        <span class="hljs-keyword">throws</span> ClassNotFoundException;

    <span class="hljs-comment">/**
     * Creates a new instance of the class represented by this {<span class="hljs-doctag">@code</span> Class}
     * object.  The class is instantiated as if by a {<span class="hljs-doctag">@code</span> new}
     * expression with an empty argument list.  The class is initialized if it
     * has not already been initialized.
     *
     * &lt;p&gt;Note that this method propagates any exception thrown by the
     * nullary constructor, including a checked exception.  Use of
     * this method effectively bypasses the compile-time exception
     * checking that would otherwise be performed by the compiler.
     * The {<span class="hljs-doctag">@link</span>
     * java.lang.reflect.Constructor#newInstance(java.lang.Object...)
     * Constructor.newInstance} method avoids this problem by wrapping
     * any exception thrown by the constructor in a (checked) {<span class="hljs-doctag">@link</span>
     * java.lang.reflect.InvocationTargetException}.
     *
     * <span class="hljs-doctag">@return</span>  a newly allocated instance of the class represented by this
     *          object.
     * <span class="hljs-doctag">@throws</span>  IllegalAccessException  if the class or its nullary
     *          constructor is not accessible.
     * <span class="hljs-doctag">@throws</span>  InstantiationException
     *          if this {<span class="hljs-doctag">@code</span> Class} represents an abstract class,
     *          an interface, an array class, a primitive type, or void;
     *          or if the class has no nullary constructor;
     *          or if the instantiation fails for some other reason.
     * <span class="hljs-doctag">@throws</span>  ExceptionInInitializerError if the initialization
     *          provoked by this method fails.
     * <span class="hljs-doctag">@throws</span>  SecurityException
     *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
     *          the caller&apos;s class loader is not the same as or an
     *          ancestor of the class loader for the current class and
     *          invocation of {<span class="hljs-doctag">@link</span> SecurityManager#checkPackageAccess
     *          s.checkPackageAccess()} denies access to the package
     *          of this class.
     */</span>
    <span class="hljs-meta">@CallerSensitive</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">newInstance</span><span class="hljs-params">()</span>
        <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException
    </span>{
        <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span>) {
            checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), <span class="hljs-keyword">false</span>);
        }

        <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> the following code may not be strictly correct under</span>
        <span class="hljs-comment">// the current Java memory model.</span>

        <span class="hljs-comment">// Constructor lookup</span>
        <span class="hljs-keyword">if</span> (cachedConstructor == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == Class.class) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalAccessException(
                    <span class="hljs-string">&quot;Can not call newInstance() on the Class for java.lang.Class&quot;</span>
                );
            }
            <span class="hljs-keyword">try</span> {
                Class&lt;?&gt;[] empty = {};
                <span class="hljs-keyword">final</span> Constructor&lt;T&gt; c = getConstructor0(empty, Member.DECLARED);
                <span class="hljs-comment">// Disable accessibility checks on the constructor</span>
                <span class="hljs-comment">// since we have to do the security check here anyway</span>
                <span class="hljs-comment">// (the stack depth is wrong for the Constructor&apos;s</span>
                <span class="hljs-comment">// security check to work)</span>
                java.security.AccessController.doPrivileged(
                    <span class="hljs-keyword">new</span> java.security.PrivilegedAction&lt;Void&gt;() {
                        <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                                c.setAccessible(<span class="hljs-keyword">true</span>);
                                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
                            }
                        });
                cachedConstructor = c;
            } <span class="hljs-keyword">catch</span> (NoSuchMethodException e) {
                <span class="hljs-keyword">throw</span> (InstantiationException)
                    <span class="hljs-keyword">new</span> InstantiationException(getName()).initCause(e);
            }
        }
        Constructor&lt;T&gt; tmpConstructor = cachedConstructor;
        <span class="hljs-comment">// Security check (same as in java.lang.reflect.Constructor)</span>
        <span class="hljs-keyword">int</span> modifiers = tmpConstructor.getModifiers();
        <span class="hljs-keyword">if</span> (!Reflection.quickCheckMemberAccess(<span class="hljs-keyword">this</span>, modifiers)) {
            Class&lt;?&gt; caller = Reflection.getCallerClass();
            <span class="hljs-keyword">if</span> (newInstanceCallerCache != caller) {
                Reflection.ensureMemberAccess(caller, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">null</span>, modifiers);
                newInstanceCallerCache = caller;
            }
        }
        <span class="hljs-comment">// Run constructor</span>
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> tmpConstructor.newInstance((Object[])<span class="hljs-keyword">null</span>);
        } <span class="hljs-keyword">catch</span> (InvocationTargetException e) {
            Unsafe.getUnsafe().throwException(e.getTargetException());
            <span class="hljs-comment">// Not reached</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        }
    }
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">transient</span> Constructor&lt;T&gt; cachedConstructor;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">transient</span> Class&lt;?&gt;       newInstanceCallerCache;


    <span class="hljs-comment">/**
     * Determines if the specified {<span class="hljs-doctag">@code</span> Object} is assignment-compatible
     * with the object represented by this {<span class="hljs-doctag">@code</span> Class}.  This method is
     * the dynamic equivalent of the Java language {<span class="hljs-doctag">@code</span> instanceof}
     * operator. The method returns {<span class="hljs-doctag">@code</span> true} if the specified
     * {<span class="hljs-doctag">@code</span> Object} argument is non-null and can be cast to the
     * reference type represented by this {<span class="hljs-doctag">@code</span> Class} object without
     * raising a {<span class="hljs-doctag">@code</span> ClassCastException.} It returns {<span class="hljs-doctag">@code</span> false}
     * otherwise.
     *
     * &lt;p&gt; Specifically, if this {<span class="hljs-doctag">@code</span> Class} object represents a
     * declared class, this method returns {<span class="hljs-doctag">@code</span> true} if the specified
     * {<span class="hljs-doctag">@code</span> Object} argument is an instance of the represented class (or
     * of any of its subclasses); it returns {<span class="hljs-doctag">@code</span> false} otherwise. If
     * this {<span class="hljs-doctag">@code</span> Class} object represents an array class, this method
     * returns {<span class="hljs-doctag">@code</span> true} if the specified {<span class="hljs-doctag">@code</span> Object} argument
     * can be converted to an object of the array class by an identity
     * conversion or by a widening reference conversion; it returns
     * {<span class="hljs-doctag">@code</span> false} otherwise. If this {<span class="hljs-doctag">@code</span> Class} object
     * represents an interface, this method returns {<span class="hljs-doctag">@code</span> true} if the
     * class or any superclass of the specified {<span class="hljs-doctag">@code</span> Object} argument
     * implements this interface; it returns {<span class="hljs-doctag">@code</span> false} otherwise. If
     * this {<span class="hljs-doctag">@code</span> Class} object represents a primitive type, this method
     * returns {<span class="hljs-doctag">@code</span> false}.
     *
     * <span class="hljs-doctag">@param</span>   obj the object to check
     * <span class="hljs-doctag">@return</span>  true if {<span class="hljs-doctag">@code</span> obj} is an instance of this class
     *
     * <span class="hljs-doctag">@since</span> JDK1.1
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isInstance</span><span class="hljs-params">(Object obj)</span></span>;


    <span class="hljs-comment">/**
     * Determines if the class or interface represented by this
     * {<span class="hljs-doctag">@code</span> Class} object is either the same as, or is a superclass or
     * superinterface of, the class or interface represented by the specified
     * {<span class="hljs-doctag">@code</span> Class} parameter. It returns {<span class="hljs-doctag">@code</span> true} if so;
     * otherwise it returns {<span class="hljs-doctag">@code</span> false}. If this {<span class="hljs-doctag">@code</span> Class}
     * object represents a primitive type, this method returns
     * {<span class="hljs-doctag">@code</span> true} if the specified {<span class="hljs-doctag">@code</span> Class} parameter is
     * exactly this {<span class="hljs-doctag">@code</span> Class} object; otherwise it returns
     * {<span class="hljs-doctag">@code</span> false}.
     *
     * &lt;p&gt; Specifically, this method tests whether the type represented by the
     * specified {<span class="hljs-doctag">@code</span> Class} parameter can be converted to the type
     * represented by this {<span class="hljs-doctag">@code</span> Class} object via an identity conversion
     * or via a widening reference conversion. See &lt;em&gt;The Java Language
     * Specification&lt;/em&gt;, sections 5.1.1 and 5.1.4 , for details.
     *
     * <span class="hljs-doctag">@param</span> cls the {<span class="hljs-doctag">@code</span> Class} object to be checked
     * <span class="hljs-doctag">@return</span> the {<span class="hljs-doctag">@code</span> boolean} value indicating whether objects of the
     * type {<span class="hljs-doctag">@code</span> cls} can be assigned to objects of this class
     * <span class="hljs-doctag">@exception</span> NullPointerException if the specified Class parameter is
     *            null.
     * <span class="hljs-doctag">@since</span> JDK1.1
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAssignableFrom</span><span class="hljs-params">(Class&lt;?&gt; cls)</span></span>;


    <span class="hljs-comment">/**
     * Determines if the specified {<span class="hljs-doctag">@code</span> Class} object represents an
     * interface type.
     *
     * <span class="hljs-doctag">@return</span>  {<span class="hljs-doctag">@code</span> true} if this object represents an interface;
     *          {<span class="hljs-doctag">@code</span> false} otherwise.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isInterface</span><span class="hljs-params">()</span></span>;


    <span class="hljs-comment">/**
     * Determines if this {<span class="hljs-doctag">@code</span> Class} object represents an array class.
     *
     * <span class="hljs-doctag">@return</span>  {<span class="hljs-doctag">@code</span> true} if this object represents an array class;
     *          {<span class="hljs-doctag">@code</span> false} otherwise.
     * <span class="hljs-doctag">@since</span>   JDK1.1
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isArray</span><span class="hljs-params">()</span></span>;


    <span class="hljs-comment">/**
     * Determines if the specified {<span class="hljs-doctag">@code</span> Class} object represents a
     * primitive type.
     *
     * &lt;p&gt; There are nine predefined {<span class="hljs-doctag">@code</span> Class} objects to represent
     * the eight primitive types and void.  These are created by the Java
     * Virtual Machine, and have the same names as the primitive types that
     * they represent, namely {<span class="hljs-doctag">@code</span> boolean}, {<span class="hljs-doctag">@code</span> byte},
     * {<span class="hljs-doctag">@code</span> char}, {<span class="hljs-doctag">@code</span> short}, {<span class="hljs-doctag">@code</span> int},
     * {<span class="hljs-doctag">@code</span> long}, {<span class="hljs-doctag">@code</span> float}, and {<span class="hljs-doctag">@code</span> double}.
     *
     * &lt;p&gt; These objects may only be accessed via the following public static
     * final variables, and are the only {<span class="hljs-doctag">@code</span> Class} objects for which
     * this method returns {<span class="hljs-doctag">@code</span> true}.
     *
     * <span class="hljs-doctag">@return</span> true if and only if this class represents a primitive type
     *
     * <span class="hljs-doctag">@see</span>     java.lang.Boolean#TYPE
     * <span class="hljs-doctag">@see</span>     java.lang.Character#TYPE
     * <span class="hljs-doctag">@see</span>     java.lang.Byte#TYPE
     * <span class="hljs-doctag">@see</span>     java.lang.Short#TYPE
     * <span class="hljs-doctag">@see</span>     java.lang.Integer#TYPE
     * <span class="hljs-doctag">@see</span>     java.lang.Long#TYPE
     * <span class="hljs-doctag">@see</span>     java.lang.Float#TYPE
     * <span class="hljs-doctag">@see</span>     java.lang.Double#TYPE
     * <span class="hljs-doctag">@see</span>     java.lang.Void#TYPE
     * <span class="hljs-doctag">@since</span> JDK1.1
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrimitive</span><span class="hljs-params">()</span></span>;

    <span class="hljs-comment">/**
     * Returns true if this {<span class="hljs-doctag">@code</span> Class} object represents an annotation
     * type.  Note that if this method returns true, {<span class="hljs-doctag">@link</span> #isInterface()}
     * would also return true, as all annotation types are also interfaces.
     *
     * <span class="hljs-doctag">@return</span> {<span class="hljs-doctag">@code</span> true} if this class object represents an annotation
     *      type; {<span class="hljs-doctag">@code</span> false} otherwise
     * <span class="hljs-doctag">@since</span> 1.5
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAnnotation</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> (getModifiers() &amp; ANNOTATION) != <span class="hljs-number">0</span>;
    }

    <span class="hljs-comment">/**
     * Returns {<span class="hljs-doctag">@code</span> true} if this class is a synthetic class;
     * returns {<span class="hljs-doctag">@code</span> false} otherwise.
     * <span class="hljs-doctag">@return</span> {<span class="hljs-doctag">@code</span> true} if and only if this class is a synthetic class as
     *         defined by the Java Language Specification.
     * <span class="hljs-doctag">@jls</span> 13.1 The Form of a Binary
     * <span class="hljs-doctag">@since</span> 1.5
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSynthetic</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> (getModifiers() &amp; SYNTHETIC) != <span class="hljs-number">0</span>;
    }

    <span class="hljs-comment">/**
     * Returns the  name of the entity (class, interface, array class,
     * primitive type, or void) represented by this {<span class="hljs-doctag">@code</span> Class} object,
     * as a {<span class="hljs-doctag">@code</span> String}.
     *
     * &lt;p&gt; If this class object represents a reference type that is not an
     * array type then the binary name of the class is returned, as specified
     * by
     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
     *
     * &lt;p&gt; If this class object represents a primitive type or void, then the
     * name returned is a {<span class="hljs-doctag">@code</span> String} equal to the Java language
     * keyword corresponding to the primitive type or void.
     *
     * &lt;p&gt; If this class object represents a class of arrays, then the internal
     * form of the name consists of the name of the element type preceded by
     * one or more &apos;{<span class="hljs-doctag">@code</span> [}&apos; characters representing the depth of the array
     * nesting.  The encoding of element type names is as follows:
     *
     * &lt;blockquote&gt;&lt;table summary=&quot;Element types and encodings&quot;&gt;
     * &lt;tr&gt;&lt;th&gt; Element Type &lt;th&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;th&gt; Encoding
     * &lt;tr&gt;&lt;td&gt; boolean      &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; Z
     * &lt;tr&gt;&lt;td&gt; byte         &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; B
     * &lt;tr&gt;&lt;td&gt; char         &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; C
     * &lt;tr&gt;&lt;td&gt; class or interface
     *                       &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; L&lt;i&gt;classname&lt;/i&gt;;
     * &lt;tr&gt;&lt;td&gt; double       &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; D
     * &lt;tr&gt;&lt;td&gt; float        &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; F
     * &lt;tr&gt;&lt;td&gt; int          &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; I
     * &lt;tr&gt;&lt;td&gt; long         &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; J
     * &lt;tr&gt;&lt;td&gt; short        &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; S
     * &lt;/table&gt;&lt;/blockquote&gt;
     *
     * &lt;p&gt; The class or interface name &lt;i&gt;classname&lt;/i&gt; is the binary name of
     * the class specified above.
     *
     * &lt;p&gt; Examples:
     * &lt;blockquote&gt;&lt;pre&gt;
     * String.class.getName()
     *     returns &quot;java.lang.String&quot;
     * byte.class.getName()
     *     returns &quot;byte&quot;
     * (new Object[3]).getClass().getName()
     *     returns &quot;[Ljava.lang.Object;&quot;
     * (new int[3][4][5][6][7][8][9]).getClass().getName()
     *     returns &quot;[[[[[[[I&quot;
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * <span class="hljs-doctag">@return</span>  the name of the class or interface
     *          represented by this object.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{
        String name = <span class="hljs-keyword">this</span>.name;
        <span class="hljs-keyword">if</span> (name == <span class="hljs-keyword">null</span>)
            <span class="hljs-keyword">this</span>.name = name = getName0();
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-comment">// cache the name to reduce the number of calls into the VM</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> String name;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> String <span class="hljs-title">getName0</span><span class="hljs-params">()</span></span>;

    <span class="hljs-comment">/**
     * Returns the class loader for the class.  Some implementations may use
     * null to represent the bootstrap class loader. This method will return
     * null in such implementations if this class was loaded by the bootstrap
     * class loader.
     *
     * &lt;p&gt; If a security manager is present, and the caller&apos;s class loader is
     * not null and the caller&apos;s class loader is not the same as or an ancestor of
     * the class loader for the class whose class loader is requested, then
     * this method calls the security manager&apos;s {<span class="hljs-doctag">@code</span> checkPermission}
     * method with a {<span class="hljs-doctag">@code</span> RuntimePermission(&quot;getClassLoader&quot;)}
     * permission to ensure it&apos;s ok to access the class loader for the class.
     *
     * &lt;p&gt;If this object
     * represents a primitive type or void, null is returned.
     *
     * <span class="hljs-doctag">@return</span>  the class loader that loaded the class or interface
     *          represented by this object.
     * <span class="hljs-doctag">@throws</span> SecurityException
     *    if a security manager exists and its
     *    {<span class="hljs-doctag">@code</span> checkPermission} method denies
     *    access to the class loader for the class.
     * <span class="hljs-doctag">@see</span> java.lang.ClassLoader
     * <span class="hljs-doctag">@see</span> SecurityManager#checkPermission
     * <span class="hljs-doctag">@see</span> java.lang.RuntimePermission
     */</span>
    <span class="hljs-meta">@CallerSensitive</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ClassLoader <span class="hljs-title">getClassLoader</span><span class="hljs-params">()</span> </span>{
        ClassLoader cl = getClassLoader0();
        <span class="hljs-keyword">if</span> (cl == <span class="hljs-keyword">null</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        SecurityManager sm = System.getSecurityManager();
        <span class="hljs-keyword">if</span> (sm != <span class="hljs-keyword">null</span>) {
            ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());
        }
        <span class="hljs-keyword">return</span> cl;
    }

    <span class="hljs-comment">// Package-private to allow ClassLoader access</span>
    <span class="hljs-function">ClassLoader <span class="hljs-title">getClassLoader0</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> classLoader; }

    <span class="hljs-comment">// Initialized in JVM not by private constructor</span>
    <span class="hljs-comment">// This field is filtered from reflection access, i.e. getDeclaredField</span>
    <span class="hljs-comment">// will throw NoSuchFieldException</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader classLoader;

    <span class="hljs-comment">/**
     * Returns an array of {<span class="hljs-doctag">@code</span> TypeVariable} objects that represent the
     * type variables declared by the generic declaration represented by this
     * {<span class="hljs-doctag">@code</span> GenericDeclaration} object, in declaration order.  Returns an
     * array of length 0 if the underlying generic declaration declares no type
     * variables.
     *
     * <span class="hljs-doctag">@return</span> an array of {<span class="hljs-doctag">@code</span> TypeVariable} objects that represent
     *     the type variables declared by this generic declaration
     * <span class="hljs-doctag">@throws</span> java.lang.reflect.GenericSignatureFormatError if the generic
     *     signature of this generic declaration does not conform to
     *     the format specified in
     *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
     * <span class="hljs-doctag">@since</span> 1.5
     */</span>
    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">&quot;unchecked&quot;</span>)
    <span class="hljs-keyword">public</span> TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters() {
        ClassRepository info = getGenericInfo();
        <span class="hljs-keyword">if</span> (info != <span class="hljs-keyword">null</span>)
            <span class="hljs-keyword">return</span> (TypeVariable&lt;Class&lt;T&gt;&gt;[])info.getTypeParameters();
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">return</span> (TypeVariable&lt;Class&lt;T&gt;&gt;[])<span class="hljs-keyword">new</span> TypeVariable&lt;?&gt;[<span class="hljs-number">0</span>];
    }


    <span class="hljs-comment">/**
     * Returns the {<span class="hljs-doctag">@code</span> Class} representing the superclass of the entity
     * (class, interface, primitive type or void) represented by this
     * {<span class="hljs-doctag">@code</span> Class}.  If this {<span class="hljs-doctag">@code</span> Class} represents either the
     * {<span class="hljs-doctag">@code</span> Object} class, an interface, a primitive type, or void, then
     * null is returned.  If this object represents an array class then the
     * {<span class="hljs-doctag">@code</span> Class} object representing the {<span class="hljs-doctag">@code</span> Object} class is
     * returned.
     *
     * <span class="hljs-doctag">@return</span> the superclass of the class represented by this object.
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> Class&lt;? <span class="hljs-keyword">super</span> T&gt; getSuperclass();


    <span class="hljs-comment">/**
     * Returns the {<span class="hljs-doctag">@code</span> Type} representing the direct superclass of
     * the entity (class, interface, primitive type or void) represented by
     * this {<span class="hljs-doctag">@code</span> Class}.
     *
     * &lt;p&gt;If the superclass is a parameterized type, the {<span class="hljs-doctag">@code</span> Type}
     * object returned must accurately reflect the actual type
     * parameters used in the source code. The parameterized type
     * representing the superclass is created if it had not been
     * created before. See the declaration of {<span class="hljs-doctag">@link</span>
     * java.lang.reflect.ParameterizedType ParameterizedType} for the
     * semantics of the creation process for parameterized types.  If
     * this {<span class="hljs-doctag">@code</span> Class} represents either the {<span class="hljs-doctag">@code</span> Object}
     * class, an interface, a primitive type, or void, then null is
     * returned.  If this object represents an array class then the
     * {<span class="hljs-doctag">@code</span> Class} object representing the {<span class="hljs-doctag">@code</span> Object} class is
     * returned.
     *
     * <span class="hljs-doctag">@throws</span> java.lang.reflect.GenericSignatureFormatError if the generic
     *     class signature does not conform to the format specified in
     *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
     * <span class="hljs-doctag">@throws</span> TypeNotPresentException if the generic superclass
     *     refers to a non-existent type declaration
     * <span class="hljs-doctag">@throws</span> java.lang.reflect.MalformedParameterizedTypeException if the
     *     generic superclass refers to a parameterized type that cannot be
     *     instantiated  for any reason
     * <span class="hljs-doctag">@return</span> the superclass of the class represented by this object
     * <span class="hljs-doctag">@since</span> 1.5
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Type <span class="hljs-title">getGenericSuperclass</span><span class="hljs-params">()</span> </span>{
        ClassRepository info = getGenericInfo();
        <span class="hljs-keyword">if</span> (info == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">return</span> getSuperclass();
        }

        <span class="hljs-comment">// Historical irregularity:</span>
        <span class="hljs-comment">// Generic signature marks interfaces with superclass = Object</span>
        <span class="hljs-comment">// but this API returns null for interfaces</span>
        <span class="hljs-keyword">if</span> (isInterface()) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        }

        <span class="hljs-keyword">return</span> info.getSuperclass();
    }

    <span class="hljs-comment">/**
     * Gets the package for this class.  The class loader of this class is used
     * to find the package.  If the class was loaded by the bootstrap class
     * loader the set of packages loaded from CLASSPATH is searched to find the
     * package of the class. Null is returned if no package object was created
     * by the class loader of this class.
     *
     * &lt;p&gt; Packages have attributes for versions and specifications only if the
     * information was defined in the manifests that accompany the classes, and
     * if the class loader created the package instance with the attributes
     * from the manifest.
     *
     * <span class="hljs-doctag">@return</span> the package of the class, or null if no package
     *         information is available from the archive or codebase.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Package <span class="hljs-title">getPackage</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> Package.getPackage(<span class="hljs-keyword">this</span>);
    }


    <span class="hljs-comment">/**
     * Determines the interfaces implemented by the class or interface
     * represented by this object.
     *
     * &lt;p&gt; If this object represents a class, the return value is an array
     * containing objects representing all interfaces implemented by the
     * class. The order of the interface objects in the array corresponds to
     * the order of the interface names in the {<span class="hljs-doctag">@code</span> implements} clause
     * of the declaration of the class represented by this object. For
     * example, given the declaration:
     * &lt;blockquote&gt;
     * {<span class="hljs-doctag">@code</span> class Shimmer implements FloorWax, DessertTopping { ... }}
     * &lt;/blockquote&gt;
     * suppose the value of {<span class="hljs-doctag">@code</span> s} is an instance of
     * {<span class="hljs-doctag">@code</span> Shimmer}; the value of the expression:
     * &lt;blockquote&gt;
     * {<span class="hljs-doctag">@code</span> s.getClass().getInterfaces()[0]}
     * &lt;/blockquote&gt;
     * is the {<span class="hljs-doctag">@code</span> Class} object that represents interface
     * {<span class="hljs-doctag">@code</span> FloorWax}; and the value of:
     * &lt;blockquote&gt;
     * {<span class="hljs-doctag">@code</span> s.getClass().getInterfaces()[1]}
     * &lt;/blockquote&gt;
     * is the {<span class="hljs-doctag">@code</span> Class} object that represents interface
     * {<span class="hljs-doctag">@code</span> DessertTopping}.
     *
     * &lt;p&gt; If this object represents an interface, the array contains objects
     * representing all interfaces extended by the interface. The order of the
     * interface objects in the array corresponds to the order of the interface
     * names in the {<span class="hljs-doctag">@code</span> extends} clause of the declaration of the
     * interface represented by this object.
     *
     * &lt;p&gt; If this object represents a class or interface that implements no
     * interfaces, the method returns an array of length 0.
     *
     * &lt;p&gt; If this object represents a primitive type or void, the method
     * returns an array of length 0.
     *
     * &lt;p&gt; If this {<span class="hljs-doctag">@code</span> Class} object represents an array type, the
     * interfaces {<span class="hljs-doctag">@code</span> Cloneable} and {<span class="hljs-doctag">@code</span> java.io.Serializable} are
     * returned in that order.
     *
     * <span class="hljs-doctag">@return</span> an array of interfaces implemented by this class.
     */</span>
    <span class="hljs-keyword">public</span> Class&lt;?&gt;[] getInterfaces() {
        ReflectionData&lt;T&gt; rd = reflectionData();
        <span class="hljs-keyword">if</span> (rd == <span class="hljs-keyword">null</span>) {
            <span class="hljs-comment">// no cloning required</span>
            <span class="hljs-keyword">return</span> getInterfaces0();
        } <span class="hljs-keyword">else</span> {
            Class&lt;?&gt;[] interfaces = rd.interfaces;
            <span class="hljs-keyword">if</span> (interfaces == <span class="hljs-keyword">null</span>) {
                interfaces = getInterfaces0();
                rd.interfaces = interfaces;
            }
            <span class="hljs-comment">// defensively copy before handing over to user code</span>
            <span class="hljs-keyword">return</span> interfaces.clone();
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> Class&lt;?&gt;[] getInterfaces0();

    <span class="hljs-comment">/**
     * Returns the {<span class="hljs-doctag">@code</span> Type}s representing the interfaces
     * directly implemented by the class or interface represented by
     * this object.
     *
     * &lt;p&gt;If a superinterface is a parameterized type, the
     * {<span class="hljs-doctag">@code</span> Type} object returned for it must accurately reflect
     * the actual type parameters used in the source code. The
     * parameterized type representing each superinterface is created
     * if it had not been created before. See the declaration of
     * {<span class="hljs-doctag">@link</span> java.lang.reflect.ParameterizedType ParameterizedType}
     * for the semantics of the creation process for parameterized
     * types.
     *
     * &lt;p&gt; If this object represents a class, the return value is an
     * array containing objects representing all interfaces
     * implemented by the class. The order of the interface objects in
     * the array corresponds to the order of the interface names in
     * the {<span class="hljs-doctag">@code</span> implements} clause of the declaration of the class
     * represented by this object.  In the case of an array class, the
     * interfaces {<span class="hljs-doctag">@code</span> Cloneable} and {<span class="hljs-doctag">@code</span> Serializable} are
     * returned in that order.
     *
     * &lt;p&gt;If this object represents an interface, the array contains
     * objects representing all interfaces directly extended by the
     * interface.  The order of the interface objects in the array
     * corresponds to the order of the interface names in the
     * {<span class="hljs-doctag">@code</span> extends} clause of the declaration of the interface
     * represented by this object.
     *
     * &lt;p&gt;If this object represents a class or interface that
     * implements no interfaces, the method returns an array of length
     * 0.
     *
     * &lt;p&gt;If this object represents a primitive type or void, the
     * method returns an array of length 0.
     *
     * <span class="hljs-doctag">@throws</span> java.lang.reflect.GenericSignatureFormatError
     *     if the generic class signature does not conform to the format
     *     specified in
     *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
     * <span class="hljs-doctag">@throws</span> TypeNotPresentException if any of the generic
     *     superinterfaces refers to a non-existent type declaration
     * <span class="hljs-doctag">@throws</span> java.lang.reflect.MalformedParameterizedTypeException
     *     if any of the generic superinterfaces refer to a parameterized
     *     type that cannot be instantiated for any reason
     * <span class="hljs-doctag">@return</span> an array of interfaces implemented by this class
     * <span class="hljs-doctag">@since</span> 1.5
     */</span>
    <span class="hljs-keyword">public</span> Type[] getGenericInterfaces() {
        ClassRepository info = getGenericInfo();
        <span class="hljs-keyword">return</span> (info == <span class="hljs-keyword">null</span>) ?  getInterfaces() : info.getSuperInterfaces();
    }


    <span class="hljs-comment">/**
     * Returns the {<span class="hljs-doctag">@code</span> Class} representing the component type of an
     * array.  If this class does not represent an array class this method
     * returns null.
     *
     * <span class="hljs-doctag">@return</span> the {<span class="hljs-doctag">@code</span> Class} representing the component type of this
     * class if this class is an array
     * <span class="hljs-doctag">@see</span>     java.lang.reflect.Array
     * <span class="hljs-doctag">@since</span> JDK1.1
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getComponentType();


    <span class="hljs-comment">/**
     * Returns the Java language modifiers for this class or interface, encoded
     * in an integer. The modifiers consist of the Java Virtual Machine&apos;s
     * constants for {<span class="hljs-doctag">@code</span> public}, {<span class="hljs-doctag">@code</span> protected},
     * {<span class="hljs-doctag">@code</span> private}, {<span class="hljs-doctag">@code</span> final}, {<span class="hljs-doctag">@code</span> static},
     * {<span class="hljs-doctag">@code</span> abstract} and {<span class="hljs-doctag">@code</span> interface}; they should be decoded
     * using the methods of class {<span class="hljs-doctag">@code</span> Modifier}.
     *
     * &lt;p&gt; If the underlying class is an array class, then its
     * {<span class="hljs-doctag">@code</span> public}, {<span class="hljs-doctag">@code</span> private} and {<span class="hljs-doctag">@code</span> protected}
     * modifiers are the same as those of its component type.  If this
     * {<span class="hljs-doctag">@code</span> Class} represents a primitive type or void, its
     * {<span class="hljs-doctag">@code</span> public} modifier is always {<span class="hljs-doctag">@code</span> true}, and its
     * {<span class="hljs-doctag">@code</span> protected} and {<span class="hljs-doctag">@code</span> private} modifiers are always
     * {<span class="hljs-doctag">@code</span> false}. If this object represents an array class, a
     * primitive type or void, then its {<span class="hljs-doctag">@code</span> final} modifier is always
     * {<span class="hljs-doctag">@code</span> true} and its interface modifier is always
     * {<span class="hljs-doctag">@code</span> false}. The values of its other modifiers are not determined
     * by this specification.
     *
     * &lt;p&gt; The modifier encodings are defined in &lt;em&gt;The Java Virtual Machine
     * Specification&lt;/em&gt;, table 4.1.
     *
     * <span class="hljs-doctag">@return</span> the {<span class="hljs-doctag">@code</span> int} representing the modifiers for this class
     * <span class="hljs-doctag">@see</span>     java.lang.reflect.Modifier
     * <span class="hljs-doctag">@since</span> JDK1.1
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getModifiers</span><span class="hljs-params">()</span></span>;


    <span class="hljs-comment">/**
     * Gets the signers of this class.
     *
     * <span class="hljs-doctag">@return</span>  the signers of this class, or null if there are no signers.  In
     *          particular, this method returns null if this object represents
     *          a primitive type or void.
     * <span class="hljs-doctag">@since</span>   JDK1.1
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> Object[] getSigners();


    <span class="hljs-comment">/**
     * Set the signers of this class.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSigners</span><span class="hljs-params">(Object[] signers)</span></span>;


    <span class="hljs-comment">/**
     * If this {<span class="hljs-doctag">@code</span> Class} object represents a local or anonymous
     * class within a method, returns a {<span class="hljs-doctag">@link</span>
     * java.lang.reflect.Method Method} object representing the
     * immediately enclosing method of the underlying class. Returns
     * {<span class="hljs-doctag">@code</span> null} otherwise.
     *
     * In particular, this method returns {<span class="hljs-doctag">@code</span> null} if the underlying
     * class is a local or anonymous class immediately enclosed by a type
     * declaration, instance initializer or static initializer.
     *
     * <span class="hljs-doctag">@return</span> the immediately enclosing method of the underlying class, if
     *     that class is a local or anonymous class; otherwise {<span class="hljs-doctag">@code</span> null}.
     *
     * <span class="hljs-doctag">@throws</span> SecurityException
     *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
     *         following conditions is met:
     *
     *         &lt;ul&gt;
     *
     *         &lt;li&gt; the caller&apos;s class loader is not the same as the
     *         class loader of the enclosing class and invocation of
     *         {<span class="hljs-doctag">@link</span> SecurityManager#checkPermission
     *         s.checkPermission} method with
     *         {<span class="hljs-doctag">@code</span> RuntimePermission(&quot;accessDeclaredMembers&quot;)}
     *         denies access to the methods within the enclosing class
     *
     *         &lt;li&gt; the caller&apos;s class loader is not the same as or an
     *         ancestor of the class loader for the enclosing class and
     *         invocation of {<span class="hljs-doctag">@link</span> SecurityManager#checkPackageAccess
     *         s.checkPackageAccess()} denies access to the package
     *         of the enclosing class
     *
     *         &lt;/ul&gt;
     * <span class="hljs-doctag">@since</span> 1.5
     */</span>
    <span class="hljs-meta">@CallerSensitive</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Method <span class="hljs-title">getEnclosingMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SecurityException </span>{
        EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();

        <span class="hljs-keyword">if</span> (enclosingInfo == <span class="hljs-keyword">null</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (!enclosingInfo.isMethod())
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;

            MethodRepository typeInfo = MethodRepository.make(enclosingInfo.getDescriptor(),
                                                              getFactory());
            Class&lt;?&gt;   returnType       = toClass(typeInfo.getReturnType());
            Type []    parameterTypes   = typeInfo.getParameterTypes();
            Class&lt;?&gt;[] parameterClasses = <span class="hljs-keyword">new</span> Class&lt;?&gt;[parameterTypes.length];

            <span class="hljs-comment">// Convert Types to Classes; returned types *should*</span>
            <span class="hljs-comment">// be class objects since the methodDescriptor&apos;s used</span>
            <span class="hljs-comment">// don&apos;t have generics information</span>
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; parameterClasses.length; i++)
                parameterClasses[i] = toClass(parameterTypes[i]);

            <span class="hljs-comment">// Perform access check</span>
            Class&lt;?&gt; enclosingCandidate = enclosingInfo.getEnclosingClass();
            enclosingCandidate.checkMemberAccess(Member.DECLARED,
                                                 Reflection.getCallerClass(), <span class="hljs-keyword">true</span>);
            <span class="hljs-comment">/*
             * Loop over all declared methods; match method name,
             * number of and type of parameters, *and* return
             * type.  Matching return type is also necessary
             * because of covariant returns, etc.
             */</span>
            <span class="hljs-keyword">for</span>(Method m: enclosingCandidate.getDeclaredMethods()) {
                <span class="hljs-keyword">if</span> (m.getName().equals(enclosingInfo.getName()) ) {
                    Class&lt;?&gt;[] candidateParamClasses = m.getParameterTypes();
                    <span class="hljs-keyword">if</span> (candidateParamClasses.length == parameterClasses.length) {
                        <span class="hljs-keyword">boolean</span> matches = <span class="hljs-keyword">true</span>;
                        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; candidateParamClasses.length; i++) {
                            <span class="hljs-keyword">if</span> (!candidateParamClasses[i].equals(parameterClasses[i])) {
                                matches = <span class="hljs-keyword">false</span>;
                                <span class="hljs-keyword">break</span>;
                            }
                        }

                        <span class="hljs-keyword">if</span> (matches) { <span class="hljs-comment">// finally, check return type</span>
                            <span class="hljs-keyword">if</span> (m.getReturnType().equals(returnType) )
                                <span class="hljs-keyword">return</span> m;
                        }
                    }
                }
            }

            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(<span class="hljs-string">&quot;Enclosing method not found&quot;</span>);
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> Object[] getEnclosingMethod0();

    <span class="hljs-function"><span class="hljs-keyword">private</span> EnclosingMethodInfo <span class="hljs-title">getEnclosingMethodInfo</span><span class="hljs-params">()</span> </span>{
        Object[] enclosingInfo = getEnclosingMethod0();
        <span class="hljs-keyword">if</span> (enclosingInfo == <span class="hljs-keyword">null</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EnclosingMethodInfo(enclosingInfo);
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnclosingMethodInfo</span> </span>{
        <span class="hljs-keyword">private</span> Class&lt;?&gt; enclosingClass;
        <span class="hljs-keyword">private</span> String name;
        <span class="hljs-keyword">private</span> String descriptor;

        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">EnclosingMethodInfo</span><span class="hljs-params">(Object[] enclosingInfo)</span> </span>{
            <span class="hljs-keyword">if</span> (enclosingInfo.length != <span class="hljs-number">3</span>)
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(<span class="hljs-string">&quot;Malformed enclosing method information&quot;</span>);
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// The array is expected to have three elements:</span>

                <span class="hljs-comment">// the immediately enclosing class</span>
                enclosingClass = (Class&lt;?&gt;) enclosingInfo[<span class="hljs-number">0</span>];
                <span class="hljs-keyword">assert</span>(enclosingClass != <span class="hljs-keyword">null</span>);

                <span class="hljs-comment">// the immediately enclosing method or constructor&apos;s</span>
                <span class="hljs-comment">// name (can be null).</span>
                name            = (String)   enclosingInfo[<span class="hljs-number">1</span>];

                <span class="hljs-comment">// the immediately enclosing method or constructor&apos;s</span>
                <span class="hljs-comment">// descriptor (null iff name is).</span>
                descriptor      = (String)   enclosingInfo[<span class="hljs-number">2</span>];
                <span class="hljs-keyword">assert</span>((name != <span class="hljs-keyword">null</span> &amp;&amp; descriptor != <span class="hljs-keyword">null</span>) || name == descriptor);
            } <span class="hljs-keyword">catch</span> (ClassCastException cce) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(<span class="hljs-string">&quot;Invalid type in enclosing method information&quot;</span>, cce);
            }
        }

        <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPartial</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> enclosingClass == <span class="hljs-keyword">null</span> || name == <span class="hljs-keyword">null</span> || descriptor == <span class="hljs-keyword">null</span>;
        }

        <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isConstructor</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> !isPartial() &amp;&amp; <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>.equals(name); }

        <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isMethod</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> !isPartial() &amp;&amp; !isConstructor() &amp;&amp; !<span class="hljs-string">&quot;&lt;clinit&gt;&quot;</span>.equals(name); }

        Class&lt;?&gt; getEnclosingClass() { <span class="hljs-keyword">return</span> enclosingClass; }

        <span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> name; }

        <span class="hljs-function">String <span class="hljs-title">getDescriptor</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> descriptor; }

    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; toClass(Type o) {
        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> GenericArrayType)
            <span class="hljs-keyword">return</span> Array.newInstance(toClass(((GenericArrayType)o).getGenericComponentType()),
                                     <span class="hljs-number">0</span>)
                .getClass();
        <span class="hljs-keyword">return</span> (Class&lt;?&gt;)o;
     }

    <span class="hljs-comment">/**
     * If this {<span class="hljs-doctag">@code</span> Class} object represents a local or anonymous
     * class within a constructor, returns a {<span class="hljs-doctag">@link</span>
     * java.lang.reflect.Constructor Constructor} object representing
     * the immediately enclosing constructor of the underlying
     * class. Returns {<span class="hljs-doctag">@code</span> null} otherwise.  In particular, this
     * method returns {<span class="hljs-doctag">@code</span> null} if the underlying class is a local
     * or anonymous class immediately enclosed by a type declaration,
     * instance initializer or static initializer.
     *
     * <span class="hljs-doctag">@return</span> the immediately enclosing constructor of the underlying class, if
     *     that class is a local or anonymous class; otherwise {<span class="hljs-doctag">@code</span> null}.
     * <span class="hljs-doctag">@throws</span> SecurityException
     *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
     *         following conditions is met:
     *
     *         &lt;ul&gt;
     *
     *         &lt;li&gt; the caller&apos;s class loader is not the same as the
     *         class loader of the enclosing class and invocation of
     *         {<span class="hljs-doctag">@link</span> SecurityManager#checkPermission
     *         s.checkPermission} method with
     *         {<span class="hljs-doctag">@code</span> RuntimePermission(&quot;accessDeclaredMembers&quot;)}
     *         denies access to the constructors within the enclosing class
     *
     *         &lt;li&gt; the caller&apos;s class loader is not the same as or an
     *         ancestor of the class loader for the enclosing class and
     *         invocation of {<span class="hljs-doctag">@link</span> SecurityManager#checkPackageAccess
     *         s.checkPackageAccess()} denies access to the package
     *         of the enclosing class
     *
     *         &lt;/ul&gt;
     * <span class="hljs-doctag">@since</span> 1.5
     */</span>
    <span class="hljs-meta">@CallerSensitive</span>
    <span class="hljs-keyword">public</span> Constructor&lt;?&gt; getEnclosingConstructor() <span class="hljs-keyword">throws</span> SecurityException {
        EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();

        <span class="hljs-keyword">if</span> (enclosingInfo == <span class="hljs-keyword">null</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (!enclosingInfo.isConstructor())
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;

            ConstructorRepository typeInfo = ConstructorRepository.make(enclosingInfo.getDescriptor(),
                                                                        getFactory());
            Type []    parameterTypes   = typeInfo.getParameterTypes();
            Class&lt;?&gt;[] parameterClasses = <span class="hljs-keyword">new</span> Class&lt;?&gt;[parameterTypes.length];

            <span class="hljs-comment">// Convert Types to Classes; returned types *should*</span>
            <span class="hljs-comment">// be class objects since the methodDescriptor&apos;s used</span>
            <span class="hljs-comment">// don&apos;t have generics information</span>
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; parameterClasses.length; i++)
                parameterClasses[i] = toClass(parameterTypes[i]);

            <span class="hljs-comment">// Perform access check</span>
            Class&lt;?&gt; enclosingCandidate = enclosingInfo.getEnclosingClass();
            enclosingCandidate.checkMemberAccess(Member.DECLARED,
                                                 Reflection.getCallerClass(), <span class="hljs-keyword">true</span>);
            <span class="hljs-comment">/*
             * Loop over all declared constructors; match number
             * of and type of parameters.
             */</span>
            <span class="hljs-keyword">for</span>(Constructor&lt;?&gt; c: enclosingCandidate.getDeclaredConstructors()) {
                Class&lt;?&gt;[] candidateParamClasses = c.getParameterTypes();
                <span class="hljs-keyword">if</span> (candidateParamClasses.length == parameterClasses.length) {
                    <span class="hljs-keyword">boolean</span> matches = <span class="hljs-keyword">true</span>;
                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; candidateParamClasses.length; i++) {
                        <span class="hljs-keyword">if</span> (!candidateParamClasses[i].equals(parameterClasses[i])) {
                            matches = <span class="hljs-keyword">false</span>;
                            <span class="hljs-keyword">break</span>;
                        }
                    }

                    <span class="hljs-keyword">if</span> (matches)
                        <span class="hljs-keyword">return</span> c;
                }
            }

            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(<span class="hljs-string">&quot;Enclosing constructor not found&quot;</span>);
        }
    }


    <span class="hljs-comment">/**
     * If the class or interface represented by this {<span class="hljs-doctag">@code</span> Class} object
     * is a member of another class, returns the {<span class="hljs-doctag">@code</span> Class} object
     * representing the class in which it was declared.  This method returns
     * null if this class or interface is not a member of any other class.  If
     * this {<span class="hljs-doctag">@code</span> Class} object represents an array class, a primitive
     * type, or void,then this method returns null.
     *
     * <span class="hljs-doctag">@return</span> the declaring class for this class
     * <span class="hljs-doctag">@throws</span> SecurityException
     *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&apos;s
     *         class loader is not the same as or an ancestor of the class
     *         loader for the declaring class and invocation of {<span class="hljs-doctag">@link</span>
     *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
     *         denies access to the package of the declaring class
     * <span class="hljs-doctag">@since</span> JDK1.1
     */</span>
    <span class="hljs-meta">@CallerSensitive</span>
    <span class="hljs-keyword">public</span> Class&lt;?&gt; getDeclaringClass() <span class="hljs-keyword">throws</span> SecurityException {
        <span class="hljs-keyword">final</span> Class&lt;?&gt; candidate = getDeclaringClass0();

        <span class="hljs-keyword">if</span> (candidate != <span class="hljs-keyword">null</span>)
            candidate.checkPackageAccess(
                    ClassLoader.getClassLoader(Reflection.getCallerClass()), <span class="hljs-keyword">true</span>);
        <span class="hljs-keyword">return</span> candidate;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getDeclaringClass0();


    <span class="hljs-comment">/**
     * Returns the immediately enclosing class of the underlying
     * class.  If the underlying class is a top level class this
     * method returns {<span class="hljs-doctag">@code</span> null}.
     * <span class="hljs-doctag">@return</span> the immediately enclosing class of the underlying class
     * <span class="hljs-doctag">@exception</span>  SecurityException
     *             If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&apos;s
     *             class loader is not the same as or an ancestor of the class
     *             loader for the enclosing class and invocation of {<span class="hljs-doctag">@link</span>
     *             SecurityManager#checkPackageAccess s.checkPackageAccess()}
     *             denies access to the package of the enclosing class
     * <span class="hljs-doctag">@since</span> 1.5
     */</span>
    <span class="hljs-meta">@CallerSensitive</span>
    <span class="hljs-keyword">public</span> Class&lt;?&gt; getEnclosingClass() <span class="hljs-keyword">throws</span> SecurityException {
        <span class="hljs-comment">// There are five kinds of classes (or interfaces):</span>
        <span class="hljs-comment">// a) Top level classes</span>
        <span class="hljs-comment">// b) Nested classes (static member classes)</span>
        <span class="hljs-comment">// c) Inner classes (non-static member classes)</span>
        <span class="hljs-comment">// d) Local classes (named classes declared within a method)</span>
        <span class="hljs-comment">// e) Anonymous classes</span>


        <span class="hljs-comment">// JVM Spec 4.8.6: A class must have an EnclosingMethod</span>
        <span class="hljs-comment">// attribute if and only if it is a local class or an</span>
        <span class="hljs-comment">// anonymous class.</span>
        EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
        Class&lt;?&gt; enclosingCandidate;

        <span class="hljs-keyword">if</span> (enclosingInfo == <span class="hljs-keyword">null</span>) {
            <span class="hljs-comment">// This is a top level or a nested class or an inner class (a, b, or c)</span>
            enclosingCandidate = getDeclaringClass();
        } <span class="hljs-keyword">else</span> {
            Class&lt;?&gt; enclosingClass = enclosingInfo.getEnclosingClass();
            <span class="hljs-comment">// This is a local class or an anonymous class (d or e)</span>
            <span class="hljs-keyword">if</span> (enclosingClass == <span class="hljs-keyword">this</span> || enclosingClass == <span class="hljs-keyword">null</span>)
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(<span class="hljs-string">&quot;Malformed enclosing method information&quot;</span>);
            <span class="hljs-keyword">else</span>
                enclosingCandidate = enclosingClass;
        }

        <span class="hljs-keyword">if</span> (enclosingCandidate != <span class="hljs-keyword">null</span>)
            enclosingCandidate.checkPackageAccess(
                    ClassLoader.getClassLoader(Reflection.getCallerClass()), <span class="hljs-keyword">true</span>);
        <span class="hljs-keyword">return</span> enclosingCandidate;
    }

    <span class="hljs-comment">/**
     * Returns the simple name of the underlying class as given in the
     * source code. Returns an empty string if the underlying class is
     * anonymous.
     *
     * &lt;p&gt;The simple name of an array is the simple name of the
     * component type with &quot;[]&quot; appended.  In particular the simple
     * name of an array whose component type is anonymous is &quot;[]&quot;.
     *
     * <span class="hljs-doctag">@return</span> the simple name of the underlying class
     * <span class="hljs-doctag">@since</span> 1.5
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSimpleName</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (isArray())
            <span class="hljs-keyword">return</span> getComponentType().getSimpleName()+<span class="hljs-string">&quot;[]&quot;</span>;

        String simpleName = getSimpleBinaryName();
        <span class="hljs-keyword">if</span> (simpleName == <span class="hljs-keyword">null</span>) { <span class="hljs-comment">// top level class</span>
            simpleName = getName();
            <span class="hljs-keyword">return</span> simpleName.substring(simpleName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>)+<span class="hljs-number">1</span>); <span class="hljs-comment">// strip the package name</span>
        }
        <span class="hljs-comment">// According to JLS3 &quot;Binary Compatibility&quot; (13.1) the binary</span>
        <span class="hljs-comment">// name of non-package classes (not top level) is the binary</span>
        <span class="hljs-comment">// name of the immediately enclosing class followed by a &apos;$&apos; followed by:</span>
        <span class="hljs-comment">// (for nested and inner classes): the simple name.</span>
        <span class="hljs-comment">// (for local classes): 1 or more digits followed by the simple name.</span>
        <span class="hljs-comment">// (for anonymous classes): 1 or more digits.</span>

        <span class="hljs-comment">// Since getSimpleBinaryName() will strip the binary name of</span>
        <span class="hljs-comment">// the immediatly enclosing class, we are now looking at a</span>
        <span class="hljs-comment">// string that matches the regular expression &quot;\$[0-9]*&quot;</span>
        <span class="hljs-comment">// followed by a simple name (considering the simple of an</span>
        <span class="hljs-comment">// anonymous class to be the empty string).</span>

        <span class="hljs-comment">// Remove leading &quot;\$[0-9]*&quot; from the name</span>
        <span class="hljs-keyword">int</span> length = simpleName.length();
        <span class="hljs-keyword">if</span> (length &lt; <span class="hljs-number">1</span> || simpleName.charAt(<span class="hljs-number">0</span>) != <span class="hljs-string">&apos;$&apos;</span>)
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(<span class="hljs-string">&quot;Malformed class name&quot;</span>);
        <span class="hljs-keyword">int</span> index = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (index &lt; length &amp;&amp; isAsciiDigit(simpleName.charAt(index)))
            index++;
        <span class="hljs-comment">// Eventually, this is the empty string iff this is an anonymous class</span>
        <span class="hljs-keyword">return</span> simpleName.substring(index);
    }

    <span class="hljs-comment">/**
     * Return an informative string for the name of this type.
     *
     * <span class="hljs-doctag">@return</span> an informative string for the name of this type
     * <span class="hljs-doctag">@since</span> 1.8
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTypeName</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (isArray()) {
            <span class="hljs-keyword">try</span> {
                Class&lt;?&gt; cl = <span class="hljs-keyword">this</span>;
                <span class="hljs-keyword">int</span> dimensions = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">while</span> (cl.isArray()) {
                    dimensions++;
                    cl = cl.getComponentType();
                }
                StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
                sb.append(cl.getName());
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dimensions; i++) {
                    sb.append(<span class="hljs-string">&quot;[]&quot;</span>);
                }
                <span class="hljs-keyword">return</span> sb.toString();
            } <span class="hljs-keyword">catch</span> (Throwable e) { <span class="hljs-comment">/*FALLTHRU*/</span> }
        }
        <span class="hljs-keyword">return</span> getName();
    }

    <span class="hljs-comment">/**
     * Character.isDigit answers {<span class="hljs-doctag">@code</span> true} to some non-ascii
     * digits.  This one does not.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAsciiDigit</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">&apos;0&apos;</span> &lt;= c &amp;&amp; c &lt;= <span class="hljs-string">&apos;9&apos;</span>;
    }

    <span class="hljs-comment">/**
     * Returns the canonical name of the underlying class as
     * defined by the Java Language Specification.  Returns null if
     * the underlying class does not have a canonical name (i.e., if
     * it is a local or anonymous class or an array whose component
     * type does not have a canonical name).
     * <span class="hljs-doctag">@return</span> the canonical name of the underlying class if it exists, and
     * {<span class="hljs-doctag">@code</span> null} otherwise.
     * <span class="hljs-doctag">@since</span> 1.5
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCanonicalName</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (isArray()) {
            String canonicalName = getComponentType().getCanonicalName();
            <span class="hljs-keyword">if</span> (canonicalName != <span class="hljs-keyword">null</span>)
                <span class="hljs-keyword">return</span> canonicalName + <span class="hljs-string">&quot;[]&quot;</span>;
            <span class="hljs-keyword">else</span>
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        }
        <span class="hljs-keyword">if</span> (isLocalOrAnonymousClass())
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        Class&lt;?&gt; enclosingClass = getEnclosingClass();
        <span class="hljs-keyword">if</span> (enclosingClass == <span class="hljs-keyword">null</span>) { <span class="hljs-comment">// top level class</span>
            <span class="hljs-keyword">return</span> getName();
        } <span class="hljs-keyword">else</span> {
            String enclosingName = enclosingClass.getCanonicalName();
            <span class="hljs-keyword">if</span> (enclosingName == <span class="hljs-keyword">null</span>)
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
            <span class="hljs-keyword">return</span> enclosingName + <span class="hljs-string">&quot;.&quot;</span> + getSimpleName();
        }
    }

    <span class="hljs-comment">/**
     * Returns {<span class="hljs-doctag">@code</span> true} if and only if the underlying class
     * is an anonymous class.
     *
     * <span class="hljs-doctag">@return</span> {<span class="hljs-doctag">@code</span> true} if and only if this class is an anonymous class.
     * <span class="hljs-doctag">@since</span> 1.5
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAnonymousClass</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>.equals(getSimpleName());
    }

    <span class="hljs-comment">/**
     * Returns {<span class="hljs-doctag">@code</span> true} if and only if the underlying class
     * is a local class.
     *
     * <span class="hljs-doctag">@return</span> {<span class="hljs-doctag">@code</span> true} if and only if this class is a local class.
     * <span class="hljs-doctag">@since</span> 1.5
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLocalClass</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> isLocalOrAnonymousClass() &amp;&amp; !isAnonymousClass();
    }

    <span class="hljs-comment">/**
     * Returns {<span class="hljs-doctag">@code</span> true} if and only if the underlying class
     * is a member class.
     *
     * <span class="hljs-doctag">@return</span> {<span class="hljs-doctag">@code</span> true} if and only if this class is a member class.
     * <span class="hljs-doctag">@since</span> 1.5
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMemberClass</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> getSimpleBinaryName() != <span class="hljs-keyword">null</span> &amp;&amp; !isLocalOrAnonymousClass();
    }

    <span class="hljs-comment">/**
     * Returns the &quot;simple binary name&quot; of the underlying class, i.e.,
     * the binary name without the leading enclosing class name.
     * Returns {<span class="hljs-doctag">@code</span> null} if the underlying class is a top level
     * class.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getSimpleBinaryName</span><span class="hljs-params">()</span> </span>{
        Class&lt;?&gt; enclosingClass = getEnclosingClass();
        <span class="hljs-keyword">if</span> (enclosingClass == <span class="hljs-keyword">null</span>) <span class="hljs-comment">// top level class</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        <span class="hljs-comment">// Otherwise, strip the enclosing class&apos; name</span>
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> getName().substring(enclosingClass.getName().length());
        } <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(<span class="hljs-string">&quot;Malformed class name&quot;</span>, ex);
        }
    }

    <span class="hljs-comment">/**
     * Returns {<span class="hljs-doctag">@code</span> true} if this is a local class or an anonymous
     * class.  Returns {<span class="hljs-doctag">@code</span> false} otherwise.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLocalOrAnonymousClass</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// JVM Spec 4.8.6: A class must have an EnclosingMethod</span>
        <span class="hljs-comment">// attribute if and only if it is a local class or an</span>
        <span class="hljs-comment">// anonymous class.</span>
        <span class="hljs-keyword">return</span> getEnclosingMethodInfo() != <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-comment">/**
     * Returns an array containing {<span class="hljs-doctag">@code</span> Class} objects representing all
     * the public classes and interfaces that are members of the class
     * represented by this {<span class="hljs-doctag">@code</span> Class} object.  This includes public
     * class and interface members inherited from superclasses and public class
     * and interface members declared by the class.  This method returns an
     * array of length 0 if this {<span class="hljs-doctag">@code</span> Class} object has no public member
     * classes or interfaces.  This method also returns an array of length 0 if
     * this {<span class="hljs-doctag">@code</span> Class} object represents a primitive type, an array
     * class, or void.
     *
     * <span class="hljs-doctag">@return</span> the array of {<span class="hljs-doctag">@code</span> Class} objects representing the public
     *         members of this class
     * <span class="hljs-doctag">@throws</span> SecurityException
     *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
     *         the caller&apos;s class loader is not the same as or an
     *         ancestor of the class loader for the current class and
     *         invocation of {<span class="hljs-doctag">@link</span> SecurityManager#checkPackageAccess
     *         s.checkPackageAccess()} denies access to the package
     *         of this class.
     *
     * <span class="hljs-doctag">@since</span> JDK1.1
     */</span>
    <span class="hljs-meta">@CallerSensitive</span>
    <span class="hljs-keyword">public</span> Class&lt;?&gt;[] getClasses() {
        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), <span class="hljs-keyword">false</span>);

        <span class="hljs-comment">// Privileged so this implementation can look at DECLARED classes,</span>
        <span class="hljs-comment">// something the caller might not have privilege to do.  The code here</span>
        <span class="hljs-comment">// is allowed to look at DECLARED classes because (1) it does not hand</span>
        <span class="hljs-comment">// out anything other than public members and (2) public member access</span>
        <span class="hljs-comment">// has already been ok&apos;d by the SecurityManager.</span>

        <span class="hljs-keyword">return</span> java.security.AccessController.doPrivileged(
            <span class="hljs-keyword">new</span> java.security.PrivilegedAction&lt;Class&lt;?&gt;[]&gt;() {
                <span class="hljs-keyword">public</span> Class&lt;?&gt;[] run() {
                    List&lt;Class&lt;?&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
                    Class&lt;?&gt; currentClass = Class.<span class="hljs-keyword">this</span>;
                    <span class="hljs-keyword">while</span> (currentClass != <span class="hljs-keyword">null</span>) {
                        Class&lt;?&gt;[] members = currentClass.getDeclaredClasses();
                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; members.length; i++) {
                            <span class="hljs-keyword">if</span> (Modifier.isPublic(members[i].getModifiers())) {
                                list.add(members[i]);
                            }
                        }
                        currentClass = currentClass.getSuperclass();
                    }
                    <span class="hljs-keyword">return</span> list.toArray(<span class="hljs-keyword">new</span> Class&lt;?&gt;[<span class="hljs-number">0</span>]);
                }
            });
    }


    <span class="hljs-comment">/**
     * Returns an array containing {<span class="hljs-doctag">@code</span> Field} objects reflecting all
     * the accessible public fields of the class or interface represented by
     * this {<span class="hljs-doctag">@code</span> Class} object.
     *
     * &lt;p&gt; If this {<span class="hljs-doctag">@code</span> Class} object represents a class or interface with no
     * no accessible public fields, then this method returns an array of length
     * 0.
     *
     * &lt;p&gt; If this {<span class="hljs-doctag">@code</span> Class} object represents a class, then this method
     * returns the public fields of the class and of all its superclasses.
     *
     * &lt;p&gt; If this {<span class="hljs-doctag">@code</span> Class} object represents an interface, then this
     * method returns the fields of the interface and of all its
     * superinterfaces.
     *
     * &lt;p&gt; If this {<span class="hljs-doctag">@code</span> Class} object represents an array type, a primitive
     * type, or void, then this method returns an array of length 0.
     *
     * &lt;p&gt; The elements in the returned array are not sorted and are not in any
     * particular order.
     *
     * <span class="hljs-doctag">@return</span> the array of {<span class="hljs-doctag">@code</span> Field} objects representing the
     *         public fields
     * <span class="hljs-doctag">@throws</span> SecurityException
     *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
     *         the caller&apos;s class loader is not the same as or an
     *         ancestor of the class loader for the current class and
     *         invocation of {<span class="hljs-doctag">@link</span> SecurityManager#checkPackageAccess
     *         s.checkPackageAccess()} denies access to the package
     *         of this class.
     *
     * <span class="hljs-doctag">@since</span> JDK1.1
     * <span class="hljs-doctag">@jls</span> 8.2 Class Members
     * <span class="hljs-doctag">@jls</span> 8.3 Field Declarations
     */</span>
    <span class="hljs-meta">@CallerSensitive</span>
    <span class="hljs-keyword">public</span> Field[] getFields() <span class="hljs-keyword">throws</span> SecurityException {
        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), <span class="hljs-keyword">true</span>);
        <span class="hljs-keyword">return</span> copyFields(privateGetPublicFields(<span class="hljs-keyword">null</span>));
    }


    <span class="hljs-comment">/**
     * Returns an array containing {<span class="hljs-doctag">@code</span> Method} objects reflecting all the
     * public methods of the class or interface represented by this {<span class="hljs-doctag">@code</span>
     * Class} object, including those declared by the class or interface and
     * those inherited from superclasses and superinterfaces.
     *
     * &lt;p&gt; If this {<span class="hljs-doctag">@code</span> Class} object represents a type that has multiple
     * public methods with the same name and parameter types, but different
     * return types, then the returned array has a {<span class="hljs-doctag">@code</span> Method} object for
     * each such method.
     *
     * &lt;p&gt; If this {<span class="hljs-doctag">@code</span> Class} object represents a type with a class
     * initialization method {<span class="hljs-doctag">@code</span> &lt;clinit&gt;}, then the returned array does
     * &lt;em&gt;not&lt;/em&gt; have a corresponding {<span class="hljs-doctag">@code</span> Method} object.
     *
     * &lt;p&gt; If this {<span class="hljs-doctag">@code</span> Class} object represents an array type, then the
     * returned array has a {<span class="hljs-doctag">@code</span> Method} object for each of the public
     * methods inherited by the array type from {<span class="hljs-doctag">@code</span> Object}. It does not
     * contain a {<span class="hljs-doctag">@code</span> Method} object for {<span class="hljs-doctag">@code</span> clone()}.
     *
     * &lt;p&gt; If this {<span class="hljs-doctag">@code</span> Class} object represents an interface then the
     * returned array does not contain any implicitly declared methods from
     * {<span class="hljs-doctag">@code</span> Object}. Therefore, if no methods are explicitly declared in
     * this interface or any of its superinterfaces then the returned array
     * has length 0. (Note that a {<span class="hljs-doctag">@code</span> Class} object which represents a class
     * always has public methods, inherited from {<span class="hljs-doctag">@code</span> Object}.)
     *
     * &lt;p&gt; If this {<span class="hljs-doctag">@code</span> Class} object represents a primitive type or void,
     * then the returned array has length 0.
     *
     * &lt;p&gt; Static methods declared in superinterfaces of the class or interface
     * represented by this {<span class="hljs-doctag">@code</span> Class} object are not considered members of
     * the class or interface.
     *
     * &lt;p&gt; The elements in the returned array are not sorted and are not in any
     * particular order.
     *
     * <span class="hljs-doctag">@return</span> the array of {<span class="hljs-doctag">@code</span> Method} objects representing the
     *         public methods of this class
     * <span class="hljs-doctag">@throws</span> SecurityException
     *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
     *         the caller&apos;s class loader is not the same as or an
     *         ancestor of the class loader for the current class and
     *         invocation of {<span class="hljs-doctag">@link</span> SecurityManager#checkPackageAccess
     *         s.checkPackageAccess()} denies access to the package
     *         of this class.
     *
     * <span class="hljs-doctag">@jls</span> 8.2 Class Members
     * <span class="hljs-doctag">@jls</span> 8.4 Method Declarations
     * <span class="hljs-doctag">@since</span> JDK1.1
     */</span>
    <span class="hljs-meta">@CallerSensitive</span>
    <span class="hljs-keyword">public</span> Method[] getMethods() <span class="hljs-keyword">throws</span> SecurityException {
        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), <span class="hljs-keyword">true</span>);
        <span class="hljs-keyword">return</span> copyMethods(privateGetPublicMethods());
    }


    <span class="hljs-comment">/**
     * Returns an array containing {<span class="hljs-doctag">@code</span> Constructor} objects reflecting
     * all the public constructors of the class represented by this
     * {<span class="hljs-doctag">@code</span> Class} object.  An array of length 0 is returned if the
     * class has no public constructors, or if the class is an array class, or
     * if the class reflects a primitive type or void.
     *
     * Note that while this method returns an array of {<span class="hljs-doctag">@code</span>
     * Constructor&lt;T&gt;} objects (that is an array of constructors from
     * this class), the return type of this method is {<span class="hljs-doctag">@code</span>
     * Constructor&lt;?&gt;[]} and &lt;em&gt;not&lt;/em&gt; {<span class="hljs-doctag">@code</span> Constructor&lt;T&gt;[]} as
     * might be expected.  This less informative return type is
     * necessary since after being returned from this method, the
     * array could be modified to hold {<span class="hljs-doctag">@code</span> Constructor} objects for
     * different classes, which would violate the type guarantees of
     * {<span class="hljs-doctag">@code</span> Constructor&lt;T&gt;[]}.
     *
     * <span class="hljs-doctag">@return</span> the array of {<span class="hljs-doctag">@code</span> Constructor} objects representing the
     *         public constructors of this class
     * <span class="hljs-doctag">@throws</span> SecurityException
     *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
     *         the caller&apos;s class loader is not the same as or an
     *         ancestor of the class loader for the current class and
     *         invocation of {<span class="hljs-doctag">@link</span> SecurityManager#checkPackageAccess
     *         s.checkPackageAccess()} denies access to the package
     *         of this class.
     *
     * <span class="hljs-doctag">@since</span> JDK1.1
     */</span>
    <span class="hljs-meta">@CallerSensitive</span>
    <span class="hljs-keyword">public</span> Constructor&lt;?&gt;[] getConstructors() <span class="hljs-keyword">throws</span> SecurityException {
        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), <span class="hljs-keyword">true</span>);
        <span class="hljs-keyword">return</span> copyConstructors(privateGetDeclaredConstructors(<span class="hljs-keyword">true</span>));
    }


    <span class="hljs-comment">/**
     * Returns a {<span class="hljs-doctag">@code</span> Field} object that reflects the specified public member
     * field of the class or interface represented by this {<span class="hljs-doctag">@code</span> Class}
     * object. The {<span class="hljs-doctag">@code</span> name} parameter is a {<span class="hljs-doctag">@code</span> String} specifying the
     * simple name of the desired field.
     *
     * &lt;p&gt; The field to be reflected is determined by the algorithm that
     * follows.  Let C be the class or interface represented by this object:
     *
     * &lt;OL&gt;
     * &lt;LI&gt; If C declares a public field with the name specified, that is the
     *      field to be reflected.&lt;/LI&gt;
     * &lt;LI&gt; If no field was found in step 1 above, this algorithm is applied
     *      recursively to each direct superinterface of C. The direct
     *      superinterfaces are searched in the order they were declared.&lt;/LI&gt;
     * &lt;LI&gt; If no field was found in steps 1 and 2 above, and C has a
     *      superclass S, then this algorithm is invoked recursively upon S.
     *      If C has no superclass, then a {<span class="hljs-doctag">@code</span> NoSuchFieldException}
     *      is thrown.&lt;/LI&gt;
     * &lt;/OL&gt;
     *
     * &lt;p&gt; If this {<span class="hljs-doctag">@code</span> Class} object represents an array type, then this
     * method does not find the {<span class="hljs-doctag">@code</span> length} field of the array type.
     *
     * <span class="hljs-doctag">@param</span> name the field name
     * <span class="hljs-doctag">@return</span> the {<span class="hljs-doctag">@code</span> Field} object of this class specified by
     *         {<span class="hljs-doctag">@code</span> name}
     * <span class="hljs-doctag">@throws</span> NoSuchFieldException if a field with the specified name is
     *         not found.
     * <span class="hljs-doctag">@throws</span> NullPointerException if {<span class="hljs-doctag">@code</span> name} is {<span class="hljs-doctag">@code</span> null}
     * <span class="hljs-doctag">@throws</span> SecurityException
     *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
     *         the caller&apos;s class loader is not the same as or an
     *         ancestor of the class loader for the current class and
     *         invocation of {<span class="hljs-doctag">@link</span> SecurityManager#checkPackageAccess
     *         s.checkPackageAccess()} denies access to the package
     *         of this class.
     *
     * <span class="hljs-doctag">@since</span> JDK1.1
     * <span class="hljs-doctag">@jls</span> 8.2 Class Members
     * <span class="hljs-doctag">@jls</span> 8.3 Field Declarations
     */</span>
    <span class="hljs-meta">@CallerSensitive</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Field <span class="hljs-title">getField</span><span class="hljs-params">(String name)</span>
        <span class="hljs-keyword">throws</span> NoSuchFieldException, SecurityException </span>{
        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), <span class="hljs-keyword">true</span>);
        Field field = getField0(name);
        <span class="hljs-keyword">if</span> (field == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchFieldException(name);
        }
        <span class="hljs-keyword">return</span> field;
    }


    <span class="hljs-comment">/**
     * Returns a {<span class="hljs-doctag">@code</span> Method} object that reflects the specified public
     * member method of the class or interface represented by this
     * {<span class="hljs-doctag">@code</span> Class} object. The {<span class="hljs-doctag">@code</span> name} parameter is a
     * {<span class="hljs-doctag">@code</span> String} specifying the simple name of the desired method. The
     * {<span class="hljs-doctag">@code</span> parameterTypes} parameter is an array of {<span class="hljs-doctag">@code</span> Class}
     * objects that identify the method&apos;s formal parameter types, in declared
     * order. If {<span class="hljs-doctag">@code</span> parameterTypes} is {<span class="hljs-doctag">@code</span> null}, it is
     * treated as if it were an empty array.
     *
     * &lt;p&gt; If the {<span class="hljs-doctag">@code</span> name} is &quot;{<span class="hljs-doctag">@code</span> &lt;init&gt;}&quot; or &quot;{<span class="hljs-doctag">@code</span> &lt;clinit&gt;}&quot; a
     * {<span class="hljs-doctag">@code</span> NoSuchMethodException} is raised. Otherwise, the method to
     * be reflected is determined by the algorithm that follows.  Let C be the
     * class or interface represented by this object:
     * &lt;OL&gt;
     * &lt;LI&gt; C is searched for a &lt;I&gt;matching method&lt;/I&gt;, as defined below. If a
     *      matching method is found, it is reflected.&lt;/LI&gt;
     * &lt;LI&gt; If no matching method is found by step 1 then:
     *   &lt;OL TYPE=&quot;a&quot;&gt;
     *   &lt;LI&gt; If C is a class other than {<span class="hljs-doctag">@code</span> Object}, then this algorithm is
     *        invoked recursively on the superclass of C.&lt;/LI&gt;
     *   &lt;LI&gt; If C is the class {<span class="hljs-doctag">@code</span> Object}, or if C is an interface, then
     *        the superinterfaces of C (if any) are searched for a matching
     *        method. If any such method is found, it is reflected.&lt;/LI&gt;
     *   &lt;/OL&gt;&lt;/LI&gt;
     * &lt;/OL&gt;
     *
     * &lt;p&gt; To find a matching method in a class or interface C:&amp;nbsp; If C
     * declares exactly one public method with the specified name and exactly
     * the same formal parameter types, that is the method reflected. If more
     * than one such method is found in C, and one of these methods has a
     * return type that is more specific than any of the others, that method is
     * reflected; otherwise one of the methods is chosen arbitrarily.
     *
     * &lt;p&gt;Note that there may be more than one matching method in a
     * class because while the Java language forbids a class to
     * declare multiple methods with the same signature but different
     * return types, the Java virtual machine does not.  This
     * increased flexibility in the virtual machine can be used to
     * implement various language features.  For example, covariant
     * returns can be implemented with {<span class="hljs-doctag">@linkplain</span>
     * java.lang.reflect.Method#isBridge bridge methods}; the bridge
     * method and the method being overridden would have the same
     * signature but different return types.
     *
     * &lt;p&gt; If this {<span class="hljs-doctag">@code</span> Class} object represents an array type, then this
     * method does not find the {<span class="hljs-doctag">@code</span> clone()} method.
     *
     * &lt;p&gt; Static methods declared in superinterfaces of the class or interface
     * represented by this {<span class="hljs-doctag">@code</span> Class} object are not considered members of
     * the class or interface.
     *
     * <span class="hljs-doctag">@param</span> name the name of the method
     * <span class="hljs-doctag">@param</span> parameterTypes the list of parameters
     * <span class="hljs-doctag">@return</span> the {<span class="hljs-doctag">@code</span> Method} object that matches the specified
     *         {<span class="hljs-doctag">@code</span> name} and {<span class="hljs-doctag">@code</span> parameterTypes}
     * <span class="hljs-doctag">@throws</span> NoSuchMethodException if a matching method is not found
     *         or if the name is &quot;&amp;lt;init&amp;gt;&quot;or &quot;&amp;lt;clinit&amp;gt;&quot;.
     * <span class="hljs-doctag">@throws</span> NullPointerException if {<span class="hljs-doctag">@code</span> name} is {<span class="hljs-doctag">@code</span> null}
     * <span class="hljs-doctag">@throws</span> SecurityException
     *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
     *         the caller&apos;s class loader is not the same as or an
     *         ancestor of the class loader for the current class and
     *         invocation of {<span class="hljs-doctag">@link</span> SecurityManager#checkPackageAccess
     *         s.checkPackageAccess()} denies access to the package
     *         of this class.
     *
     * <span class="hljs-doctag">@jls</span> 8.2 Class Members
     * <span class="hljs-doctag">@jls</span> 8.4 Method Declarations
     * <span class="hljs-doctag">@since</span> JDK1.1
     */</span>
    <span class="hljs-meta">@CallerSensitive</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Method <span class="hljs-title">getMethod</span><span class="hljs-params">(String name, Class&lt;?&gt;... parameterTypes)</span>
        <span class="hljs-keyword">throws</span> NoSuchMethodException, SecurityException </span>{
        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), <span class="hljs-keyword">true</span>);
        Method method = getMethod0(name, parameterTypes, <span class="hljs-keyword">true</span>);
        <span class="hljs-keyword">if</span> (method == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchMethodException(getName() + <span class="hljs-string">&quot;.&quot;</span> + name + argumentTypesToString(parameterTypes));
        }
        <span class="hljs-keyword">return</span> method;
    }


    <span class="hljs-comment">/**
     * Returns a {<span class="hljs-doctag">@code</span> Constructor} object that reflects the specified
     * public constructor of the class represented by this {<span class="hljs-doctag">@code</span> Class}
     * object. The {<span class="hljs-doctag">@code</span> parameterTypes} parameter is an array of
     * {<span class="hljs-doctag">@code</span> Class} objects that identify the constructor&apos;s formal
     * parameter types, in declared order.
     *
     * If this {<span class="hljs-doctag">@code</span> Class} object represents an inner class
     * declared in a non-static context, the formal parameter types
     * include the explicit enclosing instance as the first parameter.
     *
     * &lt;p&gt; The constructor to reflect is the public constructor of the class
     * represented by this {<span class="hljs-doctag">@code</span> Class} object whose formal parameter
     * types match those specified by {<span class="hljs-doctag">@code</span> parameterTypes}.
     *
     * <span class="hljs-doctag">@param</span> parameterTypes the parameter array
     * <span class="hljs-doctag">@return</span> the {<span class="hljs-doctag">@code</span> Constructor} object of the public constructor that
     *         matches the specified {<span class="hljs-doctag">@code</span> parameterTypes}
     * <span class="hljs-doctag">@throws</span> NoSuchMethodException if a matching method is not found.
     * <span class="hljs-doctag">@throws</span> SecurityException
     *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
     *         the caller&apos;s class loader is not the same as or an
     *         ancestor of the class loader for the current class and
     *         invocation of {<span class="hljs-doctag">@link</span> SecurityManager#checkPackageAccess
     *         s.checkPackageAccess()} denies access to the package
     *         of this class.
     *
     * <span class="hljs-doctag">@since</span> JDK1.1
     */</span>
    <span class="hljs-meta">@CallerSensitive</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Constructor&lt;T&gt; <span class="hljs-title">getConstructor</span><span class="hljs-params">(Class&lt;?&gt;... parameterTypes)</span>
        <span class="hljs-keyword">throws</span> NoSuchMethodException, SecurityException </span>{
        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), <span class="hljs-keyword">true</span>);
        <span class="hljs-keyword">return</span> getConstructor0(parameterTypes, Member.PUBLIC);
    }


    <span class="hljs-comment">/**
     * Returns an array of {<span class="hljs-doctag">@code</span> Class} objects reflecting all the
     * classes and interfaces declared as members of the class represented by
     * this {<span class="hljs-doctag">@code</span> Class} object. This includes public, protected, default
     * (package) access, and private classes and interfaces declared by the
     * class, but excludes inherited classes and interfaces.  This method
     * returns an array of length 0 if the class declares no classes or
     * interfaces as members, or if this {<span class="hljs-doctag">@code</span> Class} object represents a
     * primitive type, an array class, or void.
     *
     * <span class="hljs-doctag">@return</span> the array of {<span class="hljs-doctag">@code</span> Class} objects representing all the
     *         declared members of this class
     * <span class="hljs-doctag">@throws</span> SecurityException
     *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
     *         following conditions is met:
     *
     *         &lt;ul&gt;
     *
     *         &lt;li&gt; the caller&apos;s class loader is not the same as the
     *         class loader of this class and invocation of
     *         {<span class="hljs-doctag">@link</span> SecurityManager#checkPermission
     *         s.checkPermission} method with
     *         {<span class="hljs-doctag">@code</span> RuntimePermission(&quot;accessDeclaredMembers&quot;)}
     *         denies access to the declared classes within this class
     *
     *         &lt;li&gt; the caller&apos;s class loader is not the same as or an
     *         ancestor of the class loader for the current class and
     *         invocation of {<span class="hljs-doctag">@link</span> SecurityManager#checkPackageAccess
     *         s.checkPackageAccess()} denies access to the package
     *         of this class
     *
     *         &lt;/ul&gt;
     *
     * <span class="hljs-doctag">@since</span> JDK1.1
     */</span>
    <span class="hljs-meta">@CallerSensitive</span>
    <span class="hljs-keyword">public</span> Class&lt;?&gt;[] getDeclaredClasses() <span class="hljs-keyword">throws</span> SecurityException {
        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), <span class="hljs-keyword">false</span>);
        <span class="hljs-keyword">return</span> getDeclaredClasses0();
    }


    <span class="hljs-comment">/**
     * Returns an array of {<span class="hljs-doctag">@code</span> Field} objects reflecting all the fields
     * declared by the class or interface represented by this
     * {<span class="hljs-doctag">@code</span> Class} object. This includes public, protected, default
     * (package) access, and private fields, but excludes inherited fields.
     *
     * &lt;p&gt; If this {<span class="hljs-doctag">@code</span> Class} object represents a class or interface with no
     * declared fields, then this method returns an array of length 0.
     *
     * &lt;p&gt; If this {<span class="hljs-doctag">@code</span> Class} object represents an array type, a primitive
     * type, or void, then this method returns an array of length 0.
     *
     * &lt;p&gt; The elements in the returned array are not sorted and are not in any
     * particular order.
     *
     * <span class="hljs-doctag">@return</span>  the array of {<span class="hljs-doctag">@code</span> Field} objects representing all the
     *          declared fields of this class
     * <span class="hljs-doctag">@throws</span>  SecurityException
     *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
     *          following conditions is met:
     *
     *          &lt;ul&gt;
     *
     *          &lt;li&gt; the caller&apos;s class loader is not the same as the
     *          class loader of this class and invocation of
     *          {<span class="hljs-doctag">@link</span> SecurityManager#checkPermission
     *          s.checkPermission} method with
     *          {<span class="hljs-doctag">@code</span> RuntimePermission(&quot;accessDeclaredMembers&quot;)}
     *          denies access to the declared fields within this class
     *
     *          &lt;li&gt; the caller&apos;s class loader is not the same as or an
     *          ancestor of the class loader for the current class and
     *          invocation of {<span class="hljs-doctag">@link</span> SecurityManager#checkPackageAccess
     *          s.checkPackageAccess()} denies access to the package
     *          of this class
     *
     *          &lt;/ul&gt;
     *
     * <span class="hljs-doctag">@since</span> JDK1.1
     * <span class="hljs-doctag">@jls</span> 8.2 Class Members
     * <span class="hljs-doctag">@jls</span> 8.3 Field Declarations
     */</span>
    <span class="hljs-meta">@CallerSensitive</span>
    <span class="hljs-keyword">public</span> Field[] getDeclaredFields() <span class="hljs-keyword">throws</span> SecurityException {
        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), <span class="hljs-keyword">true</span>);
        <span class="hljs-keyword">return</span> copyFields(privateGetDeclaredFields(<span class="hljs-keyword">false</span>));
    }


    <span class="hljs-comment">/**
     *
     * Returns an array containing {<span class="hljs-doctag">@code</span> Method} objects reflecting all the
     * declared methods of the class or interface represented by this {<span class="hljs-doctag">@code</span>
     * Class} object, including public, protected, default (package)
     * access, and private methods, but excluding inherited methods.
     *
     * &lt;p&gt; If this {<span class="hljs-doctag">@code</span> Class} object represents a type that has multiple
     * declared methods with the same name and parameter types, but different
     * return types, then the returned array has a {<span class="hljs-doctag">@code</span> Method} object for
     * each such method.
     *
     * &lt;p&gt; If this {<span class="hljs-doctag">@code</span> Class} object represents a type that has a class
     * initialization method {<span class="hljs-doctag">@code</span> &lt;clinit&gt;}, then the returned array does
     * &lt;em&gt;not&lt;/em&gt; have a corresponding {<span class="hljs-doctag">@code</span> Method} object.
     *
     * &lt;p&gt; If this {<span class="hljs-doctag">@code</span> Class} object represents a class or interface with no
     * declared methods, then the returned array has length 0.
     *
     * &lt;p&gt; If this {<span class="hljs-doctag">@code</span> Class} object represents an array type, a primitive
     * type, or void, then the returned array has length 0.
     *
     * &lt;p&gt; The elements in the returned array are not sorted and are not in any
     * particular order.
     *
     * <span class="hljs-doctag">@return</span>  the array of {<span class="hljs-doctag">@code</span> Method} objects representing all the
     *          declared methods of this class
     * <span class="hljs-doctag">@throws</span>  SecurityException
     *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
     *          following conditions is met:
     *
     *          &lt;ul&gt;
     *
     *          &lt;li&gt; the caller&apos;s class loader is not the same as the
     *          class loader of this class and invocation of
     *          {<span class="hljs-doctag">@link</span> SecurityManager#checkPermission
     *          s.checkPermission} method with
     *          {<span class="hljs-doctag">@code</span> RuntimePermission(&quot;accessDeclaredMembers&quot;)}
     *          denies access to the declared methods within this class
     *
     *          &lt;li&gt; the caller&apos;s class loader is not the same as or an
     *          ancestor of the class loader for the current class and
     *          invocation of {<span class="hljs-doctag">@link</span> SecurityManager#checkPackageAccess
     *          s.checkPackageAccess()} denies access to the package
     *          of this class
     *
     *          &lt;/ul&gt;
     *
     * <span class="hljs-doctag">@jls</span> 8.2 Class Members
     * <span class="hljs-doctag">@jls</span> 8.4 Method Declarations
     * <span class="hljs-doctag">@since</span> JDK1.1
     */</span>
    <span class="hljs-meta">@CallerSensitive</span>
    <span class="hljs-keyword">public</span> Method[] getDeclaredMethods() <span class="hljs-keyword">throws</span> SecurityException {
        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), <span class="hljs-keyword">true</span>);
        <span class="hljs-keyword">return</span> copyMethods(privateGetDeclaredMethods(<span class="hljs-keyword">false</span>));
    }


    <span class="hljs-comment">/**
     * Returns an array of {<span class="hljs-doctag">@code</span> Constructor} objects reflecting all the
     * constructors declared by the class represented by this
     * {<span class="hljs-doctag">@code</span> Class} object. These are public, protected, default
     * (package) access, and private constructors.  The elements in the array
     * returned are not sorted and are not in any particular order.  If the
     * class has a default constructor, it is included in the returned array.
     * This method returns an array of length 0 if this {<span class="hljs-doctag">@code</span> Class}
     * object represents an interface, a primitive type, an array class, or
     * void.
     *
     * &lt;p&gt; See &lt;em&gt;The Java Language Specification&lt;/em&gt;, section 8.2.
     *
     * <span class="hljs-doctag">@return</span>  the array of {<span class="hljs-doctag">@code</span> Constructor} objects representing all the
     *          declared constructors of this class
     * <span class="hljs-doctag">@throws</span>  SecurityException
     *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
     *          following conditions is met:
     *
     *          &lt;ul&gt;
     *
     *          &lt;li&gt; the caller&apos;s class loader is not the same as the
     *          class loader of this class and invocation of
     *          {<span class="hljs-doctag">@link</span> SecurityManager#checkPermission
     *          s.checkPermission} method with
     *          {<span class="hljs-doctag">@code</span> RuntimePermission(&quot;accessDeclaredMembers&quot;)}
     *          denies access to the declared constructors within this class
     *
     *          &lt;li&gt; the caller&apos;s class loader is not the same as or an
     *          ancestor of the class loader for the current class and
     *          invocation of {<span class="hljs-doctag">@link</span> SecurityManager#checkPackageAccess
     *          s.checkPackageAccess()} denies access to the package
     *          of this class
     *
     *          &lt;/ul&gt;
     *
     * <span class="hljs-doctag">@since</span> JDK1.1
     */</span>
    <span class="hljs-meta">@CallerSensitive</span>
    <span class="hljs-keyword">public</span> Constructor&lt;?&gt;[] getDeclaredConstructors() <span class="hljs-keyword">throws</span> SecurityException {
        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), <span class="hljs-keyword">true</span>);
        <span class="hljs-keyword">return</span> copyConstructors(privateGetDeclaredConstructors(<span class="hljs-keyword">false</span>));
    }


    <span class="hljs-comment">/**
     * Returns a {<span class="hljs-doctag">@code</span> Field} object that reflects the specified declared
     * field of the class or interface represented by this {<span class="hljs-doctag">@code</span> Class}
     * object. The {<span class="hljs-doctag">@code</span> name} parameter is a {<span class="hljs-doctag">@code</span> String} that specifies
     * the simple name of the desired field.
     *
     * &lt;p&gt; If this {<span class="hljs-doctag">@code</span> Class} object represents an array type, then this
     * method does not find the {<span class="hljs-doctag">@code</span> length} field of the array type.
     *
     * <span class="hljs-doctag">@param</span> name the name of the field
     * <span class="hljs-doctag">@return</span>  the {<span class="hljs-doctag">@code</span> Field} object for the specified field in this
     *          class
     * <span class="hljs-doctag">@throws</span>  NoSuchFieldException if a field with the specified name is
     *          not found.
     * <span class="hljs-doctag">@throws</span>  NullPointerException if {<span class="hljs-doctag">@code</span> name} is {<span class="hljs-doctag">@code</span> null}
     * <span class="hljs-doctag">@throws</span>  SecurityException
     *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
     *          following conditions is met:
     *
     *          &lt;ul&gt;
     *
     *          &lt;li&gt; the caller&apos;s class loader is not the same as the
     *          class loader of this class and invocation of
     *          {<span class="hljs-doctag">@link</span> SecurityManager#checkPermission
     *          s.checkPermission} method with
     *          {<span class="hljs-doctag">@code</span> RuntimePermission(&quot;accessDeclaredMembers&quot;)}
     *          denies access to the declared field
     *
     *          &lt;li&gt; the caller&apos;s class loader is not the same as or an
     *          ancestor of the class loader for the current class and
     *          invocation of {<span class="hljs-doctag">@link</span> SecurityManager#checkPackageAccess
     *          s.checkPackageAccess()} denies access to the package
     *          of this class
     *
     *          &lt;/ul&gt;
     *
     * <span class="hljs-doctag">@since</span> JDK1.1
     * <span class="hljs-doctag">@jls</span> 8.2 Class Members
     * <span class="hljs-doctag">@jls</span> 8.3 Field Declarations
     */</span>
    <span class="hljs-meta">@CallerSensitive</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Field <span class="hljs-title">getDeclaredField</span><span class="hljs-params">(String name)</span>
        <span class="hljs-keyword">throws</span> NoSuchFieldException, SecurityException </span>{
        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), <span class="hljs-keyword">true</span>);
        Field field = searchFields(privateGetDeclaredFields(<span class="hljs-keyword">false</span>), name);
        <span class="hljs-keyword">if</span> (field == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchFieldException(name);
        }
        <span class="hljs-keyword">return</span> field;
    }


    <span class="hljs-comment">/**
     * Returns a {<span class="hljs-doctag">@code</span> Method} object that reflects the specified
     * declared method of the class or interface represented by this
     * {<span class="hljs-doctag">@code</span> Class} object. The {<span class="hljs-doctag">@code</span> name} parameter is a
     * {<span class="hljs-doctag">@code</span> String} that specifies the simple name of the desired
     * method, and the {<span class="hljs-doctag">@code</span> parameterTypes} parameter is an array of
     * {<span class="hljs-doctag">@code</span> Class} objects that identify the method&apos;s formal parameter
     * types, in declared order.  If more than one method with the same
     * parameter types is declared in a class, and one of these methods has a
     * return type that is more specific than any of the others, that method is
     * returned; otherwise one of the methods is chosen arbitrarily.  If the
     * name is &quot;&amp;lt;init&amp;gt;&quot;or &quot;&amp;lt;clinit&amp;gt;&quot; a {<span class="hljs-doctag">@code</span> NoSuchMethodException}
     * is raised.
     *
     * &lt;p&gt; If this {<span class="hljs-doctag">@code</span> Class} object represents an array type, then this
     * method does not find the {<span class="hljs-doctag">@code</span> clone()} method.
     *
     * <span class="hljs-doctag">@param</span> name the name of the method
     * <span class="hljs-doctag">@param</span> parameterTypes the parameter array
     * <span class="hljs-doctag">@return</span>  the {<span class="hljs-doctag">@code</span> Method} object for the method of this class
     *          matching the specified name and parameters
     * <span class="hljs-doctag">@throws</span>  NoSuchMethodException if a matching method is not found.
     * <span class="hljs-doctag">@throws</span>  NullPointerException if {<span class="hljs-doctag">@code</span> name} is {<span class="hljs-doctag">@code</span> null}
     * <span class="hljs-doctag">@throws</span>  SecurityException
     *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
     *          following conditions is met:
     *
     *          &lt;ul&gt;
     *
     *          &lt;li&gt; the caller&apos;s class loader is not the same as the
     *          class loader of this class and invocation of
     *          {<span class="hljs-doctag">@link</span> SecurityManager#checkPermission
     *          s.checkPermission} method with
     *          {<span class="hljs-doctag">@code</span> RuntimePermission(&quot;accessDeclaredMembers&quot;)}
     *          denies access to the declared method
     *
     *          &lt;li&gt; the caller&apos;s class loader is not the same as or an
     *          ancestor of the class loader for the current class and
     *          invocation of {<span class="hljs-doctag">@link</span> SecurityManager#checkPackageAccess
     *          s.checkPackageAccess()} denies access to the package
     *          of this class
     *
     *          &lt;/ul&gt;
     *
     * <span class="hljs-doctag">@jls</span> 8.2 Class Members
     * <span class="hljs-doctag">@jls</span> 8.4 Method Declarations
     * <span class="hljs-doctag">@since</span> JDK1.1
     */</span>
    <span class="hljs-meta">@CallerSensitive</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Method <span class="hljs-title">getDeclaredMethod</span><span class="hljs-params">(String name, Class&lt;?&gt;... parameterTypes)</span>
        <span class="hljs-keyword">throws</span> NoSuchMethodException, SecurityException </span>{
        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), <span class="hljs-keyword">true</span>);
        Method method = searchMethods(privateGetDeclaredMethods(<span class="hljs-keyword">false</span>), name, parameterTypes);
        <span class="hljs-keyword">if</span> (method == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchMethodException(getName() + <span class="hljs-string">&quot;.&quot;</span> + name + argumentTypesToString(parameterTypes));
        }
        <span class="hljs-keyword">return</span> method;
    }


    <span class="hljs-comment">/**
     * Returns a {<span class="hljs-doctag">@code</span> Constructor} object that reflects the specified
     * constructor of the class or interface represented by this
     * {<span class="hljs-doctag">@code</span> Class} object.  The {<span class="hljs-doctag">@code</span> parameterTypes} parameter is
     * an array of {<span class="hljs-doctag">@code</span> Class} objects that identify the constructor&apos;s
     * formal parameter types, in declared order.
     *
     * If this {<span class="hljs-doctag">@code</span> Class} object represents an inner class
     * declared in a non-static context, the formal parameter types
     * include the explicit enclosing instance as the first parameter.
     *
     * <span class="hljs-doctag">@param</span> parameterTypes the parameter array
     * <span class="hljs-doctag">@return</span>  The {<span class="hljs-doctag">@code</span> Constructor} object for the constructor with the
     *          specified parameter list
     * <span class="hljs-doctag">@throws</span>  NoSuchMethodException if a matching method is not found.
     * <span class="hljs-doctag">@throws</span>  SecurityException
     *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
     *          following conditions is met:
     *
     *          &lt;ul&gt;
     *
     *          &lt;li&gt; the caller&apos;s class loader is not the same as the
     *          class loader of this class and invocation of
     *          {<span class="hljs-doctag">@link</span> SecurityManager#checkPermission
     *          s.checkPermission} method with
     *          {<span class="hljs-doctag">@code</span> RuntimePermission(&quot;accessDeclaredMembers&quot;)}
     *          denies access to the declared constructor
     *
     *          &lt;li&gt; the caller&apos;s class loader is not the same as or an
     *          ancestor of the class loader for the current class and
     *          invocation of {<span class="hljs-doctag">@link</span> SecurityManager#checkPackageAccess
     *          s.checkPackageAccess()} denies access to the package
     *          of this class
     *
     *          &lt;/ul&gt;
     *
     * <span class="hljs-doctag">@since</span> JDK1.1
     */</span>
    <span class="hljs-meta">@CallerSensitive</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Constructor&lt;T&gt; <span class="hljs-title">getDeclaredConstructor</span><span class="hljs-params">(Class&lt;?&gt;... parameterTypes)</span>
        <span class="hljs-keyword">throws</span> NoSuchMethodException, SecurityException </span>{
        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), <span class="hljs-keyword">true</span>);
        <span class="hljs-keyword">return</span> getConstructor0(parameterTypes, Member.DECLARED);
    }

    <span class="hljs-comment">/**
     * Finds a resource with a given name.  The rules for searching resources
     * associated with a given class are implemented by the defining
     * {<span class="hljs-doctag">@linkplain</span> ClassLoader class loader} of the class.  This method
     * delegates to this object&apos;s class loader.  If this object was loaded by
     * the bootstrap class loader, the method delegates to {<span class="hljs-doctag">@link</span>
     * ClassLoader#getSystemResourceAsStream}.
     *
     * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
     * given resource name using this algorithm:
     *
     * &lt;ul&gt;
     *
     * &lt;li&gt; If the {<span class="hljs-doctag">@code</span> name} begins with a {<span class="hljs-doctag">@code</span> &apos;/&apos;}
     * (&lt;tt&gt;&apos;&amp;#92;u002f&apos;&lt;/tt&gt;), then the absolute name of the resource is the
     * portion of the {<span class="hljs-doctag">@code</span> name} following the {<span class="hljs-doctag">@code</span> &apos;/&apos;}.
     *
     * &lt;li&gt; Otherwise, the absolute name is of the following form:
     *
     * &lt;blockquote&gt;
     *   {<span class="hljs-doctag">@code</span> modified_package_name/name}
     * &lt;/blockquote&gt;
     *
     * &lt;p&gt; Where the {<span class="hljs-doctag">@code</span> modified_package_name} is the package name of this
     * object with {<span class="hljs-doctag">@code</span> &apos;/&apos;} substituted for {<span class="hljs-doctag">@code</span> &apos;.&apos;}
     * (&lt;tt&gt;&apos;&amp;#92;u002e&apos;&lt;/tt&gt;).
     *
     * &lt;/ul&gt;
     *
     * <span class="hljs-doctag">@param</span>  name name of the desired resource
     * <span class="hljs-doctag">@return</span>      A {<span class="hljs-doctag">@link</span> java.io.InputStream} object or {<span class="hljs-doctag">@code</span> null} if
     *              no resource with this name is found
     * <span class="hljs-doctag">@throws</span>  NullPointerException If {<span class="hljs-doctag">@code</span> name} is {<span class="hljs-doctag">@code</span> null}
     * <span class="hljs-doctag">@since</span>  JDK1.1
     */</span>
     <span class="hljs-function"><span class="hljs-keyword">public</span> InputStream <span class="hljs-title">getResourceAsStream</span><span class="hljs-params">(String name)</span> </span>{
        name = resolveName(name);
        ClassLoader cl = getClassLoader0();
        <span class="hljs-keyword">if</span> (cl==<span class="hljs-keyword">null</span>) {
            <span class="hljs-comment">// A system class.</span>
            <span class="hljs-keyword">return</span> ClassLoader.getSystemResourceAsStream(name);
        }
        <span class="hljs-keyword">return</span> cl.getResourceAsStream(name);
    }

    <span class="hljs-comment">/**
     * Finds a resource with a given name.  The rules for searching resources
     * associated with a given class are implemented by the defining
     * {<span class="hljs-doctag">@linkplain</span> ClassLoader class loader} of the class.  This method
     * delegates to this object&apos;s class loader.  If this object was loaded by
     * the bootstrap class loader, the method delegates to {<span class="hljs-doctag">@link</span>
     * ClassLoader#getSystemResource}.
     *
     * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
     * given resource name using this algorithm:
     *
     * &lt;ul&gt;
     *
     * &lt;li&gt; If the {<span class="hljs-doctag">@code</span> name} begins with a {<span class="hljs-doctag">@code</span> &apos;/&apos;}
     * (&lt;tt&gt;&apos;&amp;#92;u002f&apos;&lt;/tt&gt;), then the absolute name of the resource is the
     * portion of the {<span class="hljs-doctag">@code</span> name} following the {<span class="hljs-doctag">@code</span> &apos;/&apos;}.
     *
     * &lt;li&gt; Otherwise, the absolute name is of the following form:
     *
     * &lt;blockquote&gt;
     *   {<span class="hljs-doctag">@code</span> modified_package_name/name}
     * &lt;/blockquote&gt;
     *
     * &lt;p&gt; Where the {<span class="hljs-doctag">@code</span> modified_package_name} is the package name of this
     * object with {<span class="hljs-doctag">@code</span> &apos;/&apos;} substituted for {<span class="hljs-doctag">@code</span> &apos;.&apos;}
     * (&lt;tt&gt;&apos;&amp;#92;u002e&apos;&lt;/tt&gt;).
     *
     * &lt;/ul&gt;
     *
     * <span class="hljs-doctag">@param</span>  name name of the desired resource
     * <span class="hljs-doctag">@return</span>      A  {<span class="hljs-doctag">@link</span> java.net.URL} object or {<span class="hljs-doctag">@code</span> null} if no
     *              resource with this name is found
     * <span class="hljs-doctag">@since</span>  JDK1.1
     */</span>
    <span class="hljs-keyword">public</span> java.net.<span class="hljs-function">URL <span class="hljs-title">getResource</span><span class="hljs-params">(String name)</span> </span>{
        name = resolveName(name);
        ClassLoader cl = getClassLoader0();
        <span class="hljs-keyword">if</span> (cl==<span class="hljs-keyword">null</span>) {
            <span class="hljs-comment">// A system class.</span>
            <span class="hljs-keyword">return</span> ClassLoader.getSystemResource(name);
        }
        <span class="hljs-keyword">return</span> cl.getResource(name);
    }



    <span class="hljs-comment">/** protection domain returned when the internal domain is null */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> java.security.ProtectionDomain allPermDomain;


    <span class="hljs-comment">/**
     * Returns the {<span class="hljs-doctag">@code</span> ProtectionDomain} of this class.  If there is a
     * security manager installed, this method first calls the security
     * manager&apos;s {<span class="hljs-doctag">@code</span> checkPermission} method with a
     * {<span class="hljs-doctag">@code</span> RuntimePermission(&quot;getProtectionDomain&quot;)} permission to
     * ensure it&apos;s ok to get the
     * {<span class="hljs-doctag">@code</span> ProtectionDomain}.
     *
     * <span class="hljs-doctag">@return</span> the ProtectionDomain of this class
     *
     * <span class="hljs-doctag">@throws</span> SecurityException
     *        if a security manager exists and its
     *        {<span class="hljs-doctag">@code</span> checkPermission} method doesn&apos;t allow
     *        getting the ProtectionDomain.
     *
     * <span class="hljs-doctag">@see</span> java.security.ProtectionDomain
     * <span class="hljs-doctag">@see</span> SecurityManager#checkPermission
     * <span class="hljs-doctag">@see</span> java.lang.RuntimePermission
     * <span class="hljs-doctag">@since</span> 1.2
     */</span>
    <span class="hljs-keyword">public</span> java.security.<span class="hljs-function">ProtectionDomain <span class="hljs-title">getProtectionDomain</span><span class="hljs-params">()</span> </span>{
        SecurityManager sm = System.getSecurityManager();
        <span class="hljs-keyword">if</span> (sm != <span class="hljs-keyword">null</span>) {
            sm.checkPermission(SecurityConstants.GET_PD_PERMISSION);
        }
        java.security.ProtectionDomain pd = getProtectionDomain0();
        <span class="hljs-keyword">if</span> (pd == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">if</span> (allPermDomain == <span class="hljs-keyword">null</span>) {
                java.security.Permissions perms =
                    <span class="hljs-keyword">new</span> java.security.Permissions();
                perms.add(SecurityConstants.ALL_PERMISSION);
                allPermDomain =
                    <span class="hljs-keyword">new</span> java.security.ProtectionDomain(<span class="hljs-keyword">null</span>, perms);
            }
            pd = allPermDomain;
        }
        <span class="hljs-keyword">return</span> pd;
    }


    <span class="hljs-comment">/**
     * Returns the ProtectionDomain of this class.
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> java.security.<span class="hljs-function">ProtectionDomain <span class="hljs-title">getProtectionDomain0</span><span class="hljs-params">()</span></span>;

    <span class="hljs-comment">/*
     * Return the Virtual Machine&apos;s Class object for the named
     * primitive type.
     */</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getPrimitiveClass(String name);

    <span class="hljs-comment">/*
     * Check if client is allowed to access members.  If access is denied,
     * throw a SecurityException.
     *
     * This method also enforces package access.
     *
     * &lt;p&gt; Default policy: allow all clients access with normal Java access
     * control.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkMemberAccess</span><span class="hljs-params">(<span class="hljs-keyword">int</span> which, Class&lt;?&gt; caller, <span class="hljs-keyword">boolean</span> checkProxyInterfaces)</span> </span>{
        <span class="hljs-keyword">final</span> SecurityManager s = System.getSecurityManager();
        <span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>) {
            <span class="hljs-comment">/* Default policy allows access to all {@link Member#PUBLIC} members,
             * as well as access to classes that have the same class loader as the caller.
             * In all other cases, it requires RuntimePermission(&quot;accessDeclaredMembers&quot;)
             * permission.
             */</span>
            <span class="hljs-keyword">final</span> ClassLoader ccl = ClassLoader.getClassLoader(caller);
            <span class="hljs-keyword">final</span> ClassLoader cl = getClassLoader0();
            <span class="hljs-keyword">if</span> (which != Member.PUBLIC) {
                <span class="hljs-keyword">if</span> (ccl != cl) {
                    s.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
                }
            }
            <span class="hljs-keyword">this</span>.checkPackageAccess(ccl, checkProxyInterfaces);
        }
    }

    <span class="hljs-comment">/*
     * Checks if a client loaded in ClassLoader ccl is allowed to access this
     * class under the current package access policy. If access is denied,
     * throw a SecurityException.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkPackageAccess</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ClassLoader ccl, <span class="hljs-keyword">boolean</span> checkProxyInterfaces)</span> </span>{
        <span class="hljs-keyword">final</span> SecurityManager s = System.getSecurityManager();
        <span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">final</span> ClassLoader cl = getClassLoader0();

            <span class="hljs-keyword">if</span> (ReflectUtil.needsPackageAccessCheck(ccl, cl)) {
                String name = <span class="hljs-keyword">this</span>.getName();
                <span class="hljs-keyword">int</span> i = name.lastIndexOf(<span class="hljs-string">&apos;.&apos;</span>);
                <span class="hljs-keyword">if</span> (i != -<span class="hljs-number">1</span>) {
                    <span class="hljs-comment">// skip the package access check on a proxy class in default proxy package</span>
                    String pkg = name.substring(<span class="hljs-number">0</span>, i);
                    <span class="hljs-keyword">if</span> (!Proxy.isProxyClass(<span class="hljs-keyword">this</span>) || ReflectUtil.isNonPublicProxyClass(<span class="hljs-keyword">this</span>)) {
                        s.checkPackageAccess(pkg);
                    }
                }
            }
            <span class="hljs-comment">// check package access on the proxy interfaces</span>
            <span class="hljs-keyword">if</span> (checkProxyInterfaces &amp;&amp; Proxy.isProxyClass(<span class="hljs-keyword">this</span>)) {
                ReflectUtil.checkProxyPackageAccess(ccl, <span class="hljs-keyword">this</span>.getInterfaces());
            }
        }
    }

    <span class="hljs-comment">/**
     * Add a package name prefix if the name is not absolute Remove leading &quot;/&quot;
     * if name is absolute
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">resolveName</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">if</span> (name == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">return</span> name;
        }
        <span class="hljs-keyword">if</span> (!name.startsWith(<span class="hljs-string">&quot;/&quot;</span>)) {
            Class&lt;?&gt; c = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">while</span> (c.isArray()) {
                c = c.getComponentType();
            }
            String baseName = c.getName();
            <span class="hljs-keyword">int</span> index = baseName.lastIndexOf(<span class="hljs-string">&apos;.&apos;</span>);
            <span class="hljs-keyword">if</span> (index != -<span class="hljs-number">1</span>) {
                name = baseName.substring(<span class="hljs-number">0</span>, index).replace(<span class="hljs-string">&apos;.&apos;</span>, <span class="hljs-string">&apos;/&apos;</span>)
                    +<span class="hljs-string">&quot;/&quot;</span>+name;
            }
        } <span class="hljs-keyword">else</span> {
            name = name.substring(<span class="hljs-number">1</span>);
        }
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-comment">/**
     * Atomic operations support.
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Atomic</span> </span>{
        <span class="hljs-comment">// initialize Unsafe machinery here, since we need to call Class.class instance method</span>
        <span class="hljs-comment">// and have to avoid calling it in the static initializer of the Class class...</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();
        <span class="hljs-comment">// offset of Class.reflectionData instance field</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> reflectionDataOffset;
        <span class="hljs-comment">// offset of Class.annotationType instance field</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> annotationTypeOffset;
        <span class="hljs-comment">// offset of Class.annotationData instance field</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> annotationDataOffset;

        <span class="hljs-keyword">static</span> {
            Field[] fields = Class.class.getDeclaredFields0(<span class="hljs-keyword">false</span>); <span class="hljs-comment">// bypass caches</span>
            reflectionDataOffset = objectFieldOffset(fields, <span class="hljs-string">&quot;reflectionData&quot;</span>);
            annotationTypeOffset = objectFieldOffset(fields, <span class="hljs-string">&quot;annotationType&quot;</span>);
            annotationDataOffset = objectFieldOffset(fields, <span class="hljs-string">&quot;annotationData&quot;</span>);
        }

        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">objectFieldOffset</span><span class="hljs-params">(Field[] fields, String fieldName)</span> </span>{
            Field field = searchFields(fields, fieldName);
            <span class="hljs-keyword">if</span> (field == <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;No &quot;</span> + fieldName + <span class="hljs-string">&quot; field found in java.lang.Class&quot;</span>);
            }
            <span class="hljs-keyword">return</span> unsafe.objectFieldOffset(field);
        }

        <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">casReflectionData</span><span class="hljs-params">(Class&lt;?&gt; clazz,
                                             SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldData,
                                             SoftReference&lt;ReflectionData&lt;T&gt;&gt; newData)</span> </span>{
            <span class="hljs-keyword">return</span> unsafe.compareAndSwapObject(clazz, reflectionDataOffset, oldData, newData);
        }

        <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">casAnnotationType</span><span class="hljs-params">(Class&lt;?&gt; clazz,
                                             AnnotationType oldType,
                                             AnnotationType newType)</span> </span>{
            <span class="hljs-keyword">return</span> unsafe.compareAndSwapObject(clazz, annotationTypeOffset, oldType, newType);
        }

        <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">casAnnotationData</span><span class="hljs-params">(Class&lt;?&gt; clazz,
                                             AnnotationData oldData,
                                             AnnotationData newData)</span> </span>{
            <span class="hljs-keyword">return</span> unsafe.compareAndSwapObject(clazz, annotationDataOffset, oldData, newData);
        }
    }

    <span class="hljs-comment">/**
     * Reflection support.
     */</span>

    <span class="hljs-comment">// Caches for certain reflective results</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> useCaches = <span class="hljs-keyword">true</span>;

    <span class="hljs-comment">// reflection data that might get invalidated when JVM TI RedefineClasses() is called</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectionData</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
        <span class="hljs-keyword">volatile</span> Field[] declaredFields;
        <span class="hljs-keyword">volatile</span> Field[] publicFields;
        <span class="hljs-keyword">volatile</span> Method[] declaredMethods;
        <span class="hljs-keyword">volatile</span> Method[] publicMethods;
        <span class="hljs-keyword">volatile</span> Constructor&lt;T&gt;[] declaredConstructors;
        <span class="hljs-keyword">volatile</span> Constructor&lt;T&gt;[] publicConstructors;
        <span class="hljs-comment">// Intermediate results for getFields and getMethods</span>
        <span class="hljs-keyword">volatile</span> Field[] declaredPublicFields;
        <span class="hljs-keyword">volatile</span> Method[] declaredPublicMethods;
        <span class="hljs-keyword">volatile</span> Class&lt;?&gt;[] interfaces;

        <span class="hljs-comment">// Value of classRedefinedCount when we created this ReflectionData instance</span>
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> redefinedCount;

        ReflectionData(<span class="hljs-keyword">int</span> redefinedCount) {
            <span class="hljs-keyword">this</span>.redefinedCount = redefinedCount;
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">transient</span> SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData;

    <span class="hljs-comment">// Incremented by the VM on each call to JVM TI RedefineClasses()</span>
    <span class="hljs-comment">// that redefines this class or a superclass.</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> classRedefinedCount = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Lazily create and cache ReflectionData</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> ReflectionData&lt;T&gt; <span class="hljs-title">reflectionData</span><span class="hljs-params">()</span> </span>{
        SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData = <span class="hljs-keyword">this</span>.reflectionData;
        <span class="hljs-keyword">int</span> classRedefinedCount = <span class="hljs-keyword">this</span>.classRedefinedCount;
        ReflectionData&lt;T&gt; rd;
        <span class="hljs-keyword">if</span> (useCaches &amp;&amp;
            reflectionData != <span class="hljs-keyword">null</span> &amp;&amp;
            (rd = reflectionData.get()) != <span class="hljs-keyword">null</span> &amp;&amp;
            rd.redefinedCount == classRedefinedCount) {
            <span class="hljs-keyword">return</span> rd;
        }
        <span class="hljs-comment">// else no SoftReference or cleared SoftReference or stale ReflectionData</span>
        <span class="hljs-comment">// -&gt; create and replace new instance</span>
        <span class="hljs-keyword">return</span> newReflectionData(reflectionData, classRedefinedCount);
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> ReflectionData&lt;T&gt; <span class="hljs-title">newReflectionData</span><span class="hljs-params">(SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldReflectionData,
                                                <span class="hljs-keyword">int</span> classRedefinedCount)</span> </span>{
        <span class="hljs-keyword">if</span> (!useCaches) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
            ReflectionData&lt;T&gt; rd = <span class="hljs-keyword">new</span> ReflectionData&lt;&gt;(classRedefinedCount);
            <span class="hljs-comment">// try to CAS it...</span>
            <span class="hljs-keyword">if</span> (Atomic.casReflectionData(<span class="hljs-keyword">this</span>, oldReflectionData, <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(rd))) {
                <span class="hljs-keyword">return</span> rd;
            }
            <span class="hljs-comment">// else retry</span>
            oldReflectionData = <span class="hljs-keyword">this</span>.reflectionData;
            classRedefinedCount = <span class="hljs-keyword">this</span>.classRedefinedCount;
            <span class="hljs-keyword">if</span> (oldReflectionData != <span class="hljs-keyword">null</span> &amp;&amp;
                (rd = oldReflectionData.get()) != <span class="hljs-keyword">null</span> &amp;&amp;
                rd.redefinedCount == classRedefinedCount) {
                <span class="hljs-keyword">return</span> rd;
            }
        }
    }

    <span class="hljs-comment">// Generic signature handling</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> String <span class="hljs-title">getGenericSignature0</span><span class="hljs-params">()</span></span>;

    <span class="hljs-comment">// Generic info repository; lazily initialized</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">transient</span> ClassRepository genericInfo;

    <span class="hljs-comment">// accessor for factory</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> GenericsFactory <span class="hljs-title">getFactory</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// create scope and factory</span>
        <span class="hljs-keyword">return</span> CoreReflectionFactory.make(<span class="hljs-keyword">this</span>, ClassScope.make(<span class="hljs-keyword">this</span>));
    }

    <span class="hljs-comment">// accessor for generic info repository;</span>
    <span class="hljs-comment">// generic info is lazily initialized</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> ClassRepository <span class="hljs-title">getGenericInfo</span><span class="hljs-params">()</span> </span>{
        ClassRepository genericInfo = <span class="hljs-keyword">this</span>.genericInfo;
        <span class="hljs-keyword">if</span> (genericInfo == <span class="hljs-keyword">null</span>) {
            String signature = getGenericSignature0();
            <span class="hljs-keyword">if</span> (signature == <span class="hljs-keyword">null</span>) {
                genericInfo = ClassRepository.NONE;
            } <span class="hljs-keyword">else</span> {
                genericInfo = ClassRepository.make(signature, getFactory());
            }
            <span class="hljs-keyword">this</span>.genericInfo = genericInfo;
        }
        <span class="hljs-keyword">return</span> (genericInfo != ClassRepository.NONE) ? genericInfo : <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-comment">// Annotations handling</span>
    <span class="hljs-keyword">native</span> <span class="hljs-keyword">byte</span>[] getRawAnnotations();
    <span class="hljs-comment">// Since 1.8</span>
    <span class="hljs-keyword">native</span> <span class="hljs-keyword">byte</span>[] getRawTypeAnnotations();
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] getExecutableTypeAnnotationBytes(Executable ex) {
        <span class="hljs-keyword">return</span> getReflectionFactory().getExecutableTypeAnnotationBytes(ex);
    }

    <span class="hljs-function"><span class="hljs-keyword">native</span> ConstantPool <span class="hljs-title">getConstantPool</span><span class="hljs-params">()</span></span>;

    <span class="hljs-comment">//</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// java.lang.reflect.Field handling</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">//</span>

    <span class="hljs-comment">// Returns an array of &quot;root&quot; fields. These Field objects must NOT</span>
    <span class="hljs-comment">// be propagated to the outside world, but must instead be copied</span>
    <span class="hljs-comment">// via ReflectionFactory.copyField.</span>
    <span class="hljs-keyword">private</span> Field[] privateGetDeclaredFields(<span class="hljs-keyword">boolean</span> publicOnly) {
        checkInitted();
        Field[] res;
        ReflectionData&lt;T&gt; rd = reflectionData();
        <span class="hljs-keyword">if</span> (rd != <span class="hljs-keyword">null</span>) {
            res = publicOnly ? rd.declaredPublicFields : rd.declaredFields;
            <span class="hljs-keyword">if</span> (res != <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> res;
        }
        <span class="hljs-comment">// No cached value available; request value from VM</span>
        res = Reflection.filterFields(<span class="hljs-keyword">this</span>, getDeclaredFields0(publicOnly));
        <span class="hljs-keyword">if</span> (rd != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">if</span> (publicOnly) {
                rd.declaredPublicFields = res;
            } <span class="hljs-keyword">else</span> {
                rd.declaredFields = res;
            }
        }
        <span class="hljs-keyword">return</span> res;
    }

    <span class="hljs-comment">// Returns an array of &quot;root&quot; fields. These Field objects must NOT</span>
    <span class="hljs-comment">// be propagated to the outside world, but must instead be copied</span>
    <span class="hljs-comment">// via ReflectionFactory.copyField.</span>
    <span class="hljs-keyword">private</span> Field[] privateGetPublicFields(Set&lt;Class&lt;?&gt;&gt; traversedInterfaces) {
        checkInitted();
        Field[] res;
        ReflectionData&lt;T&gt; rd = reflectionData();
        <span class="hljs-keyword">if</span> (rd != <span class="hljs-keyword">null</span>) {
            res = rd.publicFields;
            <span class="hljs-keyword">if</span> (res != <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> res;
        }

        <span class="hljs-comment">// No cached value available; compute value recursively.</span>
        <span class="hljs-comment">// Traverse in correct order for getField().</span>
        List&lt;Field&gt; fields = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">if</span> (traversedInterfaces == <span class="hljs-keyword">null</span>) {
            traversedInterfaces = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
        }

        <span class="hljs-comment">// Local fields</span>
        Field[] tmp = privateGetDeclaredFields(<span class="hljs-keyword">true</span>);
        addAll(fields, tmp);

        <span class="hljs-comment">// Direct superinterfaces, recursively</span>
        <span class="hljs-keyword">for</span> (Class&lt;?&gt; c : getInterfaces()) {
            <span class="hljs-keyword">if</span> (!traversedInterfaces.contains(c)) {
                traversedInterfaces.add(c);
                addAll(fields, c.privateGetPublicFields(traversedInterfaces));
            }
        }

        <span class="hljs-comment">// Direct superclass, recursively</span>
        <span class="hljs-keyword">if</span> (!isInterface()) {
            Class&lt;?&gt; c = getSuperclass();
            <span class="hljs-keyword">if</span> (c != <span class="hljs-keyword">null</span>) {
                addAll(fields, c.privateGetPublicFields(traversedInterfaces));
            }
        }

        res = <span class="hljs-keyword">new</span> Field[fields.size()];
        fields.toArray(res);
        <span class="hljs-keyword">if</span> (rd != <span class="hljs-keyword">null</span>) {
            rd.publicFields = res;
        }
        <span class="hljs-keyword">return</span> res;
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAll</span><span class="hljs-params">(Collection&lt;Field&gt; c, Field[] o)</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; o.length; i++) {
            c.add(o[i]);
        }
    }


    <span class="hljs-comment">//</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// java.lang.reflect.Constructor handling</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">//</span>

    <span class="hljs-comment">// Returns an array of &quot;root&quot; constructors. These Constructor</span>
    <span class="hljs-comment">// objects must NOT be propagated to the outside world, but must</span>
    <span class="hljs-comment">// instead be copied via ReflectionFactory.copyConstructor.</span>
    <span class="hljs-keyword">private</span> Constructor&lt;T&gt;[] privateGetDeclaredConstructors(<span class="hljs-keyword">boolean</span> publicOnly) {
        checkInitted();
        Constructor&lt;T&gt;[] res;
        ReflectionData&lt;T&gt; rd = reflectionData();
        <span class="hljs-keyword">if</span> (rd != <span class="hljs-keyword">null</span>) {
            res = publicOnly ? rd.publicConstructors : rd.declaredConstructors;
            <span class="hljs-keyword">if</span> (res != <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> res;
        }
        <span class="hljs-comment">// No cached value available; request value from VM</span>
        <span class="hljs-keyword">if</span> (isInterface()) {
            <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">&quot;unchecked&quot;</span>)
            Constructor&lt;T&gt;[] temporaryRes = (Constructor&lt;T&gt;[]) <span class="hljs-keyword">new</span> Constructor&lt;?&gt;[<span class="hljs-number">0</span>];
            res = temporaryRes;
        } <span class="hljs-keyword">else</span> {
            res = getDeclaredConstructors0(publicOnly);
        }
        <span class="hljs-keyword">if</span> (rd != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">if</span> (publicOnly) {
                rd.publicConstructors = res;
            } <span class="hljs-keyword">else</span> {
                rd.declaredConstructors = res;
            }
        }
        <span class="hljs-keyword">return</span> res;
    }

    <span class="hljs-comment">//</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// java.lang.reflect.Method handling</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">//</span>

    <span class="hljs-comment">// Returns an array of &quot;root&quot; methods. These Method objects must NOT</span>
    <span class="hljs-comment">// be propagated to the outside world, but must instead be copied</span>
    <span class="hljs-comment">// via ReflectionFactory.copyMethod.</span>
    <span class="hljs-keyword">private</span> Method[] privateGetDeclaredMethods(<span class="hljs-keyword">boolean</span> publicOnly) {
        checkInitted();
        Method[] res;
        ReflectionData&lt;T&gt; rd = reflectionData();
        <span class="hljs-keyword">if</span> (rd != <span class="hljs-keyword">null</span>) {
            res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods;
            <span class="hljs-keyword">if</span> (res != <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> res;
        }
        <span class="hljs-comment">// No cached value available; request value from VM</span>
        res = Reflection.filterMethods(<span class="hljs-keyword">this</span>, getDeclaredMethods0(publicOnly));
        <span class="hljs-keyword">if</span> (rd != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">if</span> (publicOnly) {
                rd.declaredPublicMethods = res;
            } <span class="hljs-keyword">else</span> {
                rd.declaredMethods = res;
            }
        }
        <span class="hljs-keyword">return</span> res;
    }

    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodArray</span> </span>{
        <span class="hljs-comment">// Don&apos;t add or remove methods except by add() or remove() calls.</span>
        <span class="hljs-keyword">private</span> Method[] methods;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> length;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> defaults;

        MethodArray() {
            <span class="hljs-keyword">this</span>(<span class="hljs-number">20</span>);
        }

        MethodArray(<span class="hljs-keyword">int</span> initialSize) {
            <span class="hljs-keyword">if</span> (initialSize &lt; <span class="hljs-number">2</span>)
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Size should be 2 or more&quot;</span>);

            methods = <span class="hljs-keyword">new</span> Method[initialSize];
            length = <span class="hljs-number">0</span>;
            defaults = <span class="hljs-number">0</span>;
        }

        <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasDefaults</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> defaults != <span class="hljs-number">0</span>;
        }

        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Method m)</span> </span>{
            <span class="hljs-keyword">if</span> (length == methods.length) {
                methods = Arrays.copyOf(methods, <span class="hljs-number">2</span> * methods.length);
            }
            methods[length++] = m;

            <span class="hljs-keyword">if</span> (m != <span class="hljs-keyword">null</span> &amp;&amp; m.isDefault())
                defaults++;
        }

        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addAll</span><span class="hljs-params">(Method[] ma)</span> </span>{
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ma.length; i++) {
                add(ma[i]);
            }
        }

        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addAll</span><span class="hljs-params">(MethodArray ma)</span> </span>{
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ma.length(); i++) {
                add(ma.get(i));
            }
        }

        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addIfNotPresent</span><span class="hljs-params">(Method newMethod)</span> </span>{
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
                Method m = methods[i];
                <span class="hljs-keyword">if</span> (m == newMethod || (m != <span class="hljs-keyword">null</span> &amp;&amp; m.equals(newMethod))) {
                    <span class="hljs-keyword">return</span>;
                }
            }
            add(newMethod);
        }

        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addAllIfNotPresent</span><span class="hljs-params">(MethodArray newMethods)</span> </span>{
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; newMethods.length(); i++) {
                Method m = newMethods.get(i);
                <span class="hljs-keyword">if</span> (m != <span class="hljs-keyword">null</span>) {
                    addIfNotPresent(m);
                }
            }
        }

        <span class="hljs-comment">/* Add Methods declared in an interface to this MethodArray.
         * Static methods declared in interfaces are not inherited.
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addInterfaceMethods</span><span class="hljs-params">(Method[] methods)</span> </span>{
            <span class="hljs-keyword">for</span> (Method candidate : methods) {
                <span class="hljs-keyword">if</span> (!Modifier.isStatic(candidate.getModifiers())) {
                    add(candidate);
                }
            }
        }

        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> length;
        }

        <span class="hljs-function">Method <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{
            <span class="hljs-keyword">return</span> methods[i];
        }

        <span class="hljs-function">Method <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">for</span> (Method m : methods)
                <span class="hljs-keyword">if</span> (m != <span class="hljs-keyword">null</span>)
                    <span class="hljs-keyword">return</span> m;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        }

        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeByNameAndDescriptor</span><span class="hljs-params">(Method toRemove)</span> </span>{
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
                Method m = methods[i];
                <span class="hljs-keyword">if</span> (m != <span class="hljs-keyword">null</span> &amp;&amp; matchesNameAndDescriptor(m, toRemove)) {
                    remove(i);
                }
            }
        }

        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{
            <span class="hljs-keyword">if</span> (methods[i] != <span class="hljs-keyword">null</span> &amp;&amp; methods[i].isDefault())
                defaults--;
            methods[i] = <span class="hljs-keyword">null</span>;
        }

        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matchesNameAndDescriptor</span><span class="hljs-params">(Method m1, Method m2)</span> </span>{
            <span class="hljs-keyword">return</span> m1.getReturnType() == m2.getReturnType() &amp;&amp;
                   m1.getName() == m2.getName() &amp;&amp; <span class="hljs-comment">// name is guaranteed to be interned</span>
                   arrayContentsEq(m1.getParameterTypes(),
                           m2.getParameterTypes());
        }

        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">compactAndTrim</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">int</span> newPos = <span class="hljs-number">0</span>;
            <span class="hljs-comment">// Get rid of null slots</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>; pos &lt; length; pos++) {
                Method m = methods[pos];
                <span class="hljs-keyword">if</span> (m != <span class="hljs-keyword">null</span>) {
                    <span class="hljs-keyword">if</span> (pos != newPos) {
                        methods[newPos] = m;
                    }
                    newPos++;
                }
            }
            <span class="hljs-keyword">if</span> (newPos != methods.length) {
                methods = Arrays.copyOf(methods, newPos);
            }
        }

        <span class="hljs-comment">/* Removes all Methods from this MethodArray that have a more specific
         * default Method in this MethodArray.
         *
         * Users of MethodArray are responsible for pruning Methods that have
         * a more specific &lt;em&gt;concrete&lt;/em&gt; Method.
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeLessSpecifics</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">if</span> (!hasDefaults())
                <span class="hljs-keyword">return</span>;

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
                Method m = get(i);
                <span class="hljs-keyword">if</span>  (m == <span class="hljs-keyword">null</span> || !m.isDefault())
                    <span class="hljs-keyword">continue</span>;

                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j  = <span class="hljs-number">0</span>; j &lt; length; j++) {
                    <span class="hljs-keyword">if</span> (i == j)
                        <span class="hljs-keyword">continue</span>;

                    Method candidate = get(j);
                    <span class="hljs-keyword">if</span> (candidate == <span class="hljs-keyword">null</span>)
                        <span class="hljs-keyword">continue</span>;

                    <span class="hljs-keyword">if</span> (!matchesNameAndDescriptor(m, candidate))
                        <span class="hljs-keyword">continue</span>;

                    <span class="hljs-keyword">if</span> (hasMoreSpecificClass(m, candidate))
                        remove(j);
                }
            }
        }

        Method[] getArray() {
            <span class="hljs-keyword">return</span> methods;
        }

        <span class="hljs-comment">// Returns true if m1 is more specific than m2</span>
        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasMoreSpecificClass</span><span class="hljs-params">(Method m1, Method m2)</span> </span>{
            Class&lt;?&gt; m1Class = m1.getDeclaringClass();
            Class&lt;?&gt; m2Class = m2.getDeclaringClass();
            <span class="hljs-keyword">return</span> m1Class != m2Class &amp;&amp; m2Class.isAssignableFrom(m1Class);
        }
    }


    <span class="hljs-comment">// Returns an array of &quot;root&quot; methods. These Method objects must NOT</span>
    <span class="hljs-comment">// be propagated to the outside world, but must instead be copied</span>
    <span class="hljs-comment">// via ReflectionFactory.copyMethod.</span>
    <span class="hljs-keyword">private</span> Method[] privateGetPublicMethods() {
        checkInitted();
        Method[] res;
        ReflectionData&lt;T&gt; rd = reflectionData();
        <span class="hljs-keyword">if</span> (rd != <span class="hljs-keyword">null</span>) {
            res = rd.publicMethods;
            <span class="hljs-keyword">if</span> (res != <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> res;
        }

        <span class="hljs-comment">// No cached value available; compute value recursively.</span>
        <span class="hljs-comment">// Start by fetching public declared methods</span>
        MethodArray methods = <span class="hljs-keyword">new</span> MethodArray();
        {
            Method[] tmp = privateGetDeclaredMethods(<span class="hljs-keyword">true</span>);
            methods.addAll(tmp);
        }
        <span class="hljs-comment">// Now recur over superclass and direct superinterfaces.</span>
        <span class="hljs-comment">// Go over superinterfaces first so we can more easily filter</span>
        <span class="hljs-comment">// out concrete implementations inherited from superclasses at</span>
        <span class="hljs-comment">// the end.</span>
        MethodArray inheritedMethods = <span class="hljs-keyword">new</span> MethodArray();
        <span class="hljs-keyword">for</span> (Class&lt;?&gt; i : getInterfaces()) {
            inheritedMethods.addInterfaceMethods(i.privateGetPublicMethods());
        }
        <span class="hljs-keyword">if</span> (!isInterface()) {
            Class&lt;?&gt; c = getSuperclass();
            <span class="hljs-keyword">if</span> (c != <span class="hljs-keyword">null</span>) {
                MethodArray supers = <span class="hljs-keyword">new</span> MethodArray();
                supers.addAll(c.privateGetPublicMethods());
                <span class="hljs-comment">// Filter out concrete implementations of any</span>
                <span class="hljs-comment">// interface methods</span>
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; supers.length(); i++) {
                    Method m = supers.get(i);
                    <span class="hljs-keyword">if</span> (m != <span class="hljs-keyword">null</span> &amp;&amp;
                            !Modifier.isAbstract(m.getModifiers()) &amp;&amp;
                            !m.isDefault()) {
                        inheritedMethods.removeByNameAndDescriptor(m);
                    }
                }
                <span class="hljs-comment">// Insert superclass&apos;s inherited methods before</span>
                <span class="hljs-comment">// superinterfaces&apos; to satisfy getMethod&apos;s search</span>
                <span class="hljs-comment">// order</span>
                supers.addAll(inheritedMethods);
                inheritedMethods = supers;
            }
        }
        <span class="hljs-comment">// Filter out all local methods from inherited ones</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; methods.length(); i++) {
            Method m = methods.get(i);
            inheritedMethods.removeByNameAndDescriptor(m);
        }
        methods.addAllIfNotPresent(inheritedMethods);
        methods.removeLessSpecifics();
        methods.compactAndTrim();
        res = methods.getArray();
        <span class="hljs-keyword">if</span> (rd != <span class="hljs-keyword">null</span>) {
            rd.publicMethods = res;
        }
        <span class="hljs-keyword">return</span> res;
    }


    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Helpers for fetchers of one field, method, or constructor</span>
    <span class="hljs-comment">//</span>

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Field <span class="hljs-title">searchFields</span><span class="hljs-params">(Field[] fields, String name)</span> </span>{
        String internedName = name.intern();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fields.length; i++) {
            <span class="hljs-keyword">if</span> (fields[i].getName() == internedName) {
                <span class="hljs-keyword">return</span> getReflectionFactory().copyField(fields[i]);
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> Field <span class="hljs-title">getField0</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException </span>{
        <span class="hljs-comment">// Note: the intent is that the search algorithm this routine</span>
        <span class="hljs-comment">// uses be equivalent to the ordering imposed by</span>
        <span class="hljs-comment">// privateGetPublicFields(). It fetches only the declared</span>
        <span class="hljs-comment">// public fields for each class, however, to reduce the number</span>
        <span class="hljs-comment">// of Field objects which have to be created for the common</span>
        <span class="hljs-comment">// case where the field being requested is declared in the</span>
        <span class="hljs-comment">// class which is being queried.</span>
        Field res;
        <span class="hljs-comment">// Search declared public fields</span>
        <span class="hljs-keyword">if</span> ((res = searchFields(privateGetDeclaredFields(<span class="hljs-keyword">true</span>), name)) != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">return</span> res;
        }
        <span class="hljs-comment">// Direct superinterfaces, recursively</span>
        Class&lt;?&gt;[] interfaces = getInterfaces();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; interfaces.length; i++) {
            Class&lt;?&gt; c = interfaces[i];
            <span class="hljs-keyword">if</span> ((res = c.getField0(name)) != <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">return</span> res;
            }
        }
        <span class="hljs-comment">// Direct superclass, recursively</span>
        <span class="hljs-keyword">if</span> (!isInterface()) {
            Class&lt;?&gt; c = getSuperclass();
            <span class="hljs-keyword">if</span> (c != <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">if</span> ((res = c.getField0(name)) != <span class="hljs-keyword">null</span>) {
                    <span class="hljs-keyword">return</span> res;
                }
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method <span class="hljs-title">searchMethods</span><span class="hljs-params">(Method[] methods,
                                        String name,
                                        Class&lt;?&gt;[] parameterTypes)</span>
    </span>{
        Method res = <span class="hljs-keyword">null</span>;
        String internedName = name.intern();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; methods.length; i++) {
            Method m = methods[i];
            <span class="hljs-keyword">if</span> (m.getName() == internedName
                &amp;&amp; arrayContentsEq(parameterTypes, m.getParameterTypes())
                &amp;&amp; (res == <span class="hljs-keyword">null</span>
                    || res.getReturnType().isAssignableFrom(m.getReturnType())))
                res = m;
        }

        <span class="hljs-keyword">return</span> (res == <span class="hljs-keyword">null</span> ? res : getReflectionFactory().copyMethod(res));
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> Method <span class="hljs-title">getMethod0</span><span class="hljs-params">(String name, Class&lt;?&gt;[] parameterTypes, <span class="hljs-keyword">boolean</span> includeStaticMethods)</span> </span>{
        MethodArray interfaceCandidates = <span class="hljs-keyword">new</span> MethodArray(<span class="hljs-number">2</span>);
        Method res =  privateGetMethodRecursive(name, parameterTypes, includeStaticMethods, interfaceCandidates);
        <span class="hljs-keyword">if</span> (res != <span class="hljs-keyword">null</span>)
            <span class="hljs-keyword">return</span> res;

        <span class="hljs-comment">// Not found on class or superclass directly</span>
        interfaceCandidates.removeLessSpecifics();
        <span class="hljs-keyword">return</span> interfaceCandidates.getFirst(); <span class="hljs-comment">// may be null</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> Method <span class="hljs-title">privateGetMethodRecursive</span><span class="hljs-params">(String name,
            Class&lt;?&gt;[] parameterTypes,
            <span class="hljs-keyword">boolean</span> includeStaticMethods,
            MethodArray allInterfaceCandidates)</span> </span>{
        <span class="hljs-comment">// Note: the intent is that the search algorithm this routine</span>
        <span class="hljs-comment">// uses be equivalent to the ordering imposed by</span>
        <span class="hljs-comment">// privateGetPublicMethods(). It fetches only the declared</span>
        <span class="hljs-comment">// public methods for each class, however, to reduce the</span>
        <span class="hljs-comment">// number of Method objects which have to be created for the</span>
        <span class="hljs-comment">// common case where the method being requested is declared in</span>
        <span class="hljs-comment">// the class which is being queried.</span>
        <span class="hljs-comment">//</span>
        <span class="hljs-comment">// Due to default methods, unless a method is found on a superclass,</span>
        <span class="hljs-comment">// methods declared in any superinterface needs to be considered.</span>
        <span class="hljs-comment">// Collect all candidates declared in superinterfaces in {@code</span>
        <span class="hljs-comment">// allInterfaceCandidates} and select the most specific if no match on</span>
        <span class="hljs-comment">// a superclass is found.</span>

        <span class="hljs-comment">// Must _not_ return root methods</span>
        Method res;
        <span class="hljs-comment">// Search declared public methods</span>
        <span class="hljs-keyword">if</span> ((res = searchMethods(privateGetDeclaredMethods(<span class="hljs-keyword">true</span>),
                                 name,
                                 parameterTypes)) != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">if</span> (includeStaticMethods || !Modifier.isStatic(res.getModifiers()))
                <span class="hljs-keyword">return</span> res;
        }
        <span class="hljs-comment">// Search superclass&apos;s methods</span>
        <span class="hljs-keyword">if</span> (!isInterface()) {
            Class&lt;? <span class="hljs-keyword">super</span> T&gt; c = getSuperclass();
            <span class="hljs-keyword">if</span> (c != <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">if</span> ((res = c.getMethod0(name, parameterTypes, <span class="hljs-keyword">true</span>)) != <span class="hljs-keyword">null</span>) {
                    <span class="hljs-keyword">return</span> res;
                }
            }
        }
        <span class="hljs-comment">// Search superinterfaces&apos; methods</span>
        Class&lt;?&gt;[] interfaces = getInterfaces();
        <span class="hljs-keyword">for</span> (Class&lt;?&gt; c : interfaces)
            <span class="hljs-keyword">if</span> ((res = c.getMethod0(name, parameterTypes, <span class="hljs-keyword">false</span>)) != <span class="hljs-keyword">null</span>)
                allInterfaceCandidates.add(res);
        <span class="hljs-comment">// Not found</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> Constructor&lt;T&gt; <span class="hljs-title">getConstructor0</span><span class="hljs-params">(Class&lt;?&gt;[] parameterTypes,
                                        <span class="hljs-keyword">int</span> which)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException
    </span>{
        Constructor&lt;T&gt;[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC));
        <span class="hljs-keyword">for</span> (Constructor&lt;T&gt; constructor : constructors) {
            <span class="hljs-keyword">if</span> (arrayContentsEq(parameterTypes,
                                constructor.getParameterTypes())) {
                <span class="hljs-keyword">return</span> getReflectionFactory().copyConstructor(constructor);
            }
        }
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchMethodException(getName() + <span class="hljs-string">&quot;.&lt;init&gt;&quot;</span> + argumentTypesToString(parameterTypes));
    }

    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Other helpers and base implementation</span>
    <span class="hljs-comment">//</span>

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">arrayContentsEq</span><span class="hljs-params">(Object[] a1, Object[] a2)</span> </span>{
        <span class="hljs-keyword">if</span> (a1 == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">return</span> a2 == <span class="hljs-keyword">null</span> || a2.length == <span class="hljs-number">0</span>;
        }

        <span class="hljs-keyword">if</span> (a2 == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">return</span> a1.length == <span class="hljs-number">0</span>;
        }

        <span class="hljs-keyword">if</span> (a1.length != a2.length) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a1.length; i++) {
            <span class="hljs-keyword">if</span> (a1[i] != a2[i]) {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Field[] copyFields(Field[] arg) {
        Field[] out = <span class="hljs-keyword">new</span> Field[arg.length];
        ReflectionFactory fact = getReflectionFactory();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arg.length; i++) {
            out[i] = fact.copyField(arg[i]);
        }
        <span class="hljs-keyword">return</span> out;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method[] copyMethods(Method[] arg) {
        Method[] out = <span class="hljs-keyword">new</span> Method[arg.length];
        ReflectionFactory fact = getReflectionFactory();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arg.length; i++) {
            out[i] = fact.copyMethod(arg[i]);
        }
        <span class="hljs-keyword">return</span> out;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;U&gt; Constructor&lt;U&gt;[] copyConstructors(Constructor&lt;U&gt;[] arg) {
        Constructor&lt;U&gt;[] out = arg.clone();
        ReflectionFactory fact = getReflectionFactory();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; out.length; i++) {
            out[i] = fact.copyConstructor(out[i]);
        }
        <span class="hljs-keyword">return</span> out;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> Field[]       getDeclaredFields0(<span class="hljs-keyword">boolean</span> publicOnly);
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> Method[]      getDeclaredMethods0(<span class="hljs-keyword">boolean</span> publicOnly);
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> Constructor&lt;T&gt;[] getDeclaredConstructors0(<span class="hljs-keyword">boolean</span> publicOnly);
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> Class&lt;?&gt;[]   getDeclaredClasses0();

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String        <span class="hljs-title">argumentTypesToString</span><span class="hljs-params">(Class&lt;?&gt;[] argTypes)</span> </span>{
        StringBuilder buf = <span class="hljs-keyword">new</span> StringBuilder();
        buf.append(<span class="hljs-string">&quot;(&quot;</span>);
        <span class="hljs-keyword">if</span> (argTypes != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; argTypes.length; i++) {
                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) {
                    buf.append(<span class="hljs-string">&quot;, &quot;</span>);
                }
                Class&lt;?&gt; c = argTypes[i];
                buf.append((c == <span class="hljs-keyword">null</span>) ? <span class="hljs-string">&quot;null&quot;</span> : c.getName());
            }
        }
        buf.append(<span class="hljs-string">&quot;)&quot;</span>);
        <span class="hljs-keyword">return</span> buf.toString();
    }

    <span class="hljs-comment">/** use serialVersionUID from JDK 1.1 for interoperability */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">3206093459760846163L</span>;


    <span class="hljs-comment">/**
     * Class Class is special cased within the Serialization Stream Protocol.
     *
     * A Class instance is written initially into an ObjectOutputStream in the
     * following format:
     * &lt;pre&gt;
     *      {<span class="hljs-doctag">@code</span> TC_CLASS} ClassDescriptor
     *      A ClassDescriptor is a special cased serialization of
     *      a {<span class="hljs-doctag">@code</span> java.io.ObjectStreamClass} instance.
     * &lt;/pre&gt;
     * A new handle is generated for the initial time the class descriptor
     * is written into the stream. Future references to the class descriptor
     * are written as references to the initial class descriptor instance.
     *
     * <span class="hljs-doctag">@see</span> java.io.ObjectStreamClass
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ObjectStreamField[] serialPersistentFields =
        <span class="hljs-keyword">new</span> ObjectStreamField[<span class="hljs-number">0</span>];


    <span class="hljs-comment">/**
     * Returns the assertion status that would be assigned to this
     * class if it were to be initialized at the time this method is invoked.
     * If this class has had its assertion status set, the most recent
     * setting will be returned; otherwise, if any package default assertion
     * status pertains to this class, the most recent setting for the most
     * specific pertinent package default assertion status is returned;
     * otherwise, if this class is not a system class (i.e., it has a
     * class loader) its class loader&apos;s default assertion status is returned;
     * otherwise, the system class default assertion status is returned.
     * &lt;p&gt;
     * Few programmers will have any need for this method; it is provided
     * for the benefit of the JRE itself.  (It allows a class to determine at
     * the time that it is initialized whether assertions should be enabled.)
     * Note that this method is not guaranteed to return the actual
     * assertion status that was (or will be) associated with the specified
     * class when it was (or will be) initialized.
     *
     * <span class="hljs-doctag">@return</span> the desired assertion status of the specified class.
     * <span class="hljs-doctag">@see</span>    java.lang.ClassLoader#setClassAssertionStatus
     * <span class="hljs-doctag">@see</span>    java.lang.ClassLoader#setPackageAssertionStatus
     * <span class="hljs-doctag">@see</span>    java.lang.ClassLoader#setDefaultAssertionStatus
     * <span class="hljs-doctag">@since</span>  1.4
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">desiredAssertionStatus</span><span class="hljs-params">()</span> </span>{
        ClassLoader loader = getClassLoader();
        <span class="hljs-comment">// If the loader is null this is a system class, so ask the VM</span>
        <span class="hljs-keyword">if</span> (loader == <span class="hljs-keyword">null</span>)
            <span class="hljs-keyword">return</span> desiredAssertionStatus0(<span class="hljs-keyword">this</span>);

        <span class="hljs-comment">// If the classloader has been initialized with the assertion</span>
        <span class="hljs-comment">// directives, ask it. Otherwise, ask the VM.</span>
        <span class="hljs-keyword">synchronized</span>(loader.assertionLock) {
            <span class="hljs-keyword">if</span> (loader.classAssertionStatus != <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">return</span> loader.desiredAssertionStatus(getName());
            }
        }
        <span class="hljs-keyword">return</span> desiredAssertionStatus0(<span class="hljs-keyword">this</span>);
    }

    <span class="hljs-comment">// Retrieves the desired assertion status of this class from the VM</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">desiredAssertionStatus0</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span></span>;

    <span class="hljs-comment">/**
     * Returns true if and only if this class was declared as an enum in the
     * source code.
     *
     * <span class="hljs-doctag">@return</span> true if and only if this class was declared as an enum in the
     *     source code
     * <span class="hljs-doctag">@since</span> 1.5
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnum</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// An enum must both directly extend java.lang.Enum and have</span>
        <span class="hljs-comment">// the ENUM bit set; classes for specialized enum constants</span>
        <span class="hljs-comment">// don&apos;t do the former.</span>
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.getModifiers() &amp; ENUM) != <span class="hljs-number">0</span> &amp;&amp;
        <span class="hljs-keyword">this</span>.getSuperclass() == java.lang.Enum.class;
    }

    <span class="hljs-comment">// Fetches the factory for reflective objects</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ReflectionFactory <span class="hljs-title">getReflectionFactory</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (reflectionFactory == <span class="hljs-keyword">null</span>) {
            reflectionFactory =
                java.security.AccessController.doPrivileged
                    (<span class="hljs-keyword">new</span> sun.reflect.ReflectionFactory.GetReflectionFactoryAction());
        }
        <span class="hljs-keyword">return</span> reflectionFactory;
    }
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ReflectionFactory reflectionFactory;

    <span class="hljs-comment">// To be able to query system properties as soon as they&apos;re available</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> initted = <span class="hljs-keyword">false</span>;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkInitted</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (initted) <span class="hljs-keyword">return</span>;
        AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() {
                <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                    <span class="hljs-comment">// Tests to ensure the system properties table is fully</span>
                    <span class="hljs-comment">// initialized. This is needed because reflection code is</span>
                    <span class="hljs-comment">// called very early in the initialization process (before</span>
                    <span class="hljs-comment">// command-line arguments have been parsed and therefore</span>
                    <span class="hljs-comment">// these user-settable properties installed.) We assume that</span>
                    <span class="hljs-comment">// if System.out is non-null then the System class has been</span>
                    <span class="hljs-comment">// fully initialized and that the bulk of the startup code</span>
                    <span class="hljs-comment">// has been run.</span>

                    <span class="hljs-keyword">if</span> (System.out == <span class="hljs-keyword">null</span>) {
                        <span class="hljs-comment">// java.lang.System not yet fully initialized</span>
                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
                    }

                    <span class="hljs-comment">// Doesn&apos;t use Boolean.getBoolean to avoid class init.</span>
                    String val =
                        System.getProperty(<span class="hljs-string">&quot;sun.reflect.noCaches&quot;</span>);
                    <span class="hljs-keyword">if</span> (val != <span class="hljs-keyword">null</span> &amp;&amp; val.equals(<span class="hljs-string">&quot;true&quot;</span>)) {
                        useCaches = <span class="hljs-keyword">false</span>;
                    }

                    initted = <span class="hljs-keyword">true</span>;
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
                }
            });
    }

    <span class="hljs-comment">/**
     * Returns the elements of this enum class or null if this
     * Class object does not represent an enum type.
     *
     * <span class="hljs-doctag">@return</span> an array containing the values comprising the enum class
     *     represented by this Class object in the order they&apos;re
     *     declared, or null if this Class object does not
     *     represent an enum type
     * <span class="hljs-doctag">@since</span> 1.5
     */</span>
    <span class="hljs-keyword">public</span> T[] getEnumConstants() {
        T[] values = getEnumConstantsShared();
        <span class="hljs-keyword">return</span> (values != <span class="hljs-keyword">null</span>) ? values.clone() : <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-comment">/**
     * Returns the elements of this enum class or null if this
     * Class object does not represent an enum type;
     * identical to getEnumConstants except that the result is
     * uncloned, cached, and shared by all callers.
     */</span>
    T[] getEnumConstantsShared() {
        <span class="hljs-keyword">if</span> (enumConstants == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">if</span> (!isEnum()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">final</span> Method values = getMethod(<span class="hljs-string">&quot;values&quot;</span>);
                java.security.AccessController.doPrivileged(
                    <span class="hljs-keyword">new</span> java.security.PrivilegedAction&lt;Void&gt;() {
                        <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                                values.setAccessible(<span class="hljs-keyword">true</span>);
                                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
                            }
                        });
                <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">&quot;unchecked&quot;</span>)
                T[] temporaryConstants = (T[])values.invoke(<span class="hljs-keyword">null</span>);
                enumConstants = temporaryConstants;
            }
            <span class="hljs-comment">// These can happen when users concoct enum-like classes</span>
            <span class="hljs-comment">// that don&apos;t comply with the enum spec.</span>
            <span class="hljs-keyword">catch</span> (InvocationTargetException | NoSuchMethodException |
                   IllegalAccessException ex) { <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; }
        }
        <span class="hljs-keyword">return</span> enumConstants;
    }
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">transient</span> T[] enumConstants = <span class="hljs-keyword">null</span>;

    <span class="hljs-comment">/**
     * Returns a map from simple name to enum constant.  This package-private
     * method is used internally by Enum to implement
     * {<span class="hljs-doctag">@code</span> public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt;, String)}
     * efficiently.  Note that the map is returned by this method is
     * created lazily on first use.  Typically it won&apos;t ever get created.
     */</span>
    <span class="hljs-function">Map&lt;String, T&gt; <span class="hljs-title">enumConstantDirectory</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (enumConstantDirectory == <span class="hljs-keyword">null</span>) {
            T[] universe = getEnumConstantsShared();
            <span class="hljs-keyword">if</span> (universe == <span class="hljs-keyword">null</span>)
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(
                    getName() + <span class="hljs-string">&quot; is not an enum type&quot;</span>);
            Map&lt;String, T&gt; m = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">2</span> * universe.length);
            <span class="hljs-keyword">for</span> (T constant : universe)
                m.put(((Enum&lt;?&gt;)constant).name(), constant);
            enumConstantDirectory = m;
        }
        <span class="hljs-keyword">return</span> enumConstantDirectory;
    }
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">transient</span> Map&lt;String, T&gt; enumConstantDirectory = <span class="hljs-keyword">null</span>;

    <span class="hljs-comment">/**
     * Casts an object to the class or interface represented
     * by this {<span class="hljs-doctag">@code</span> Class} object.
     *
     * <span class="hljs-doctag">@param</span> obj the object to be cast
     * <span class="hljs-doctag">@return</span> the object after casting, or null if obj is null
     *
     * <span class="hljs-doctag">@throws</span> ClassCastException if the object is not
     * null and is not assignable to the type T.
     *
     * <span class="hljs-doctag">@since</span> 1.5
     */</span>
    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">&quot;unchecked&quot;</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">cast</span><span class="hljs-params">(Object obj)</span> </span>{
        <span class="hljs-keyword">if</span> (obj != <span class="hljs-keyword">null</span> &amp;&amp; !isInstance(obj))
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassCastException(cannotCastMsg(obj));
        <span class="hljs-keyword">return</span> (T) obj;
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">cannotCastMsg</span><span class="hljs-params">(Object obj)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Cannot cast &quot;</span> + obj.getClass().getName() + <span class="hljs-string">&quot; to &quot;</span> + getName();
    }

    <span class="hljs-comment">/**
     * Casts this {<span class="hljs-doctag">@code</span> Class} object to represent a subclass of the class
     * represented by the specified class object.  Checks that the cast
     * is valid, and throws a {<span class="hljs-doctag">@code</span> ClassCastException} if it is not.  If
     * this method succeeds, it always returns a reference to this class object.
     *
     * &lt;p&gt;This method is useful when a client needs to &quot;narrow&quot; the type of
     * a {<span class="hljs-doctag">@code</span> Class} object to pass it to an API that restricts the
     * {<span class="hljs-doctag">@code</span> Class} objects that it is willing to accept.  A cast would
     * generate a compile-time warning, as the correctness of the cast
     * could not be checked at runtime (because generic types are implemented
     * by erasure).
     *
     * <span class="hljs-doctag">@param</span> &lt;U&gt; the type to cast this class object to
     * <span class="hljs-doctag">@param</span> clazz the class of the type to cast this class object to
     * <span class="hljs-doctag">@return</span> this {<span class="hljs-doctag">@code</span> Class} object, cast to represent a subclass of
     *    the specified class object.
     * <span class="hljs-doctag">@throws</span> ClassCastException if this {<span class="hljs-doctag">@code</span> Class} object does not
     *    represent a subclass of the specified class (here &quot;subclass&quot; includes
     *    the class itself).
     * <span class="hljs-doctag">@since</span> 1.5
     */</span>
    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">&quot;unchecked&quot;</span>)
    <span class="hljs-keyword">public</span> &lt;U&gt; Class&lt;? extends U&gt; asSubclass(Class&lt;U&gt; clazz) {
        <span class="hljs-keyword">if</span> (clazz.isAssignableFrom(<span class="hljs-keyword">this</span>))
            <span class="hljs-keyword">return</span> (Class&lt;? extends U&gt;) <span class="hljs-keyword">this</span>;
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassCastException(<span class="hljs-keyword">this</span>.toString());
    }

    <span class="hljs-comment">/**
     * <span class="hljs-doctag">@throws</span> NullPointerException {<span class="hljs-doctag">@inheritDoc</span>}
     * <span class="hljs-doctag">@since</span> 1.5
     */</span>
    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">&quot;unchecked&quot;</span>)
    <span class="hljs-keyword">public</span> &lt;A extends Annotation&gt; <span class="hljs-function">A <span class="hljs-title">getAnnotation</span><span class="hljs-params">(Class&lt;A&gt; annotationClass)</span> </span>{
        Objects.requireNonNull(annotationClass);

        <span class="hljs-keyword">return</span> (A) annotationData().annotations.get(annotationClass);
    }

    <span class="hljs-comment">/**
     * {<span class="hljs-doctag">@inheritDoc</span>}
     * <span class="hljs-doctag">@throws</span> NullPointerException {<span class="hljs-doctag">@inheritDoc</span>}
     * <span class="hljs-doctag">@since</span> 1.5
     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAnnotationPresent</span><span class="hljs-params">(Class&lt;? extends Annotation&gt; annotationClass)</span> </span>{
        <span class="hljs-keyword">return</span> GenericDeclaration.<span class="hljs-keyword">super</span>.isAnnotationPresent(annotationClass);
    }

    <span class="hljs-comment">/**
     * <span class="hljs-doctag">@throws</span> NullPointerException {<span class="hljs-doctag">@inheritDoc</span>}
     * <span class="hljs-doctag">@since</span> 1.8
     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> &lt;A extends Annotation&gt; A[] getAnnotationsByType(Class&lt;A&gt; annotationClass) {
        Objects.requireNonNull(annotationClass);

        AnnotationData annotationData = annotationData();
        <span class="hljs-keyword">return</span> AnnotationSupport.getAssociatedAnnotations(annotationData.declaredAnnotations,
                                                          <span class="hljs-keyword">this</span>,
                                                          annotationClass);
    }

    <span class="hljs-comment">/**
     * <span class="hljs-doctag">@since</span> 1.5
     */</span>
    <span class="hljs-keyword">public</span> Annotation[] getAnnotations() {
        <span class="hljs-keyword">return</span> AnnotationParser.toArray(annotationData().annotations);
    }

    <span class="hljs-comment">/**
     * <span class="hljs-doctag">@throws</span> NullPointerException {<span class="hljs-doctag">@inheritDoc</span>}
     * <span class="hljs-doctag">@since</span> 1.8
     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">&quot;unchecked&quot;</span>)
    <span class="hljs-keyword">public</span> &lt;A extends Annotation&gt; <span class="hljs-function">A <span class="hljs-title">getDeclaredAnnotation</span><span class="hljs-params">(Class&lt;A&gt; annotationClass)</span> </span>{
        Objects.requireNonNull(annotationClass);

        <span class="hljs-keyword">return</span> (A) annotationData().declaredAnnotations.get(annotationClass);
    }

    <span class="hljs-comment">/**
     * <span class="hljs-doctag">@throws</span> NullPointerException {<span class="hljs-doctag">@inheritDoc</span>}
     * <span class="hljs-doctag">@since</span> 1.8
     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> &lt;A extends Annotation&gt; A[] getDeclaredAnnotationsByType(Class&lt;A&gt; annotationClass) {
        Objects.requireNonNull(annotationClass);

        <span class="hljs-keyword">return</span> AnnotationSupport.getDirectlyAndIndirectlyPresent(annotationData().declaredAnnotations,
                                                                 annotationClass);
    }

    <span class="hljs-comment">/**
     * <span class="hljs-doctag">@since</span> 1.5
     */</span>
    <span class="hljs-keyword">public</span> Annotation[] getDeclaredAnnotations()  {
        <span class="hljs-keyword">return</span> AnnotationParser.toArray(annotationData().declaredAnnotations);
    }

    <span class="hljs-comment">// annotation data that might get invalidated when JVM TI RedefineClasses() is called</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationData</span> </span>{
        <span class="hljs-keyword">final</span> Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations;
        <span class="hljs-keyword">final</span> Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;

        <span class="hljs-comment">// Value of classRedefinedCount when we created this AnnotationData instance</span>
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> redefinedCount;

        AnnotationData(Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations,
                       Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations,
                       <span class="hljs-keyword">int</span> redefinedCount) {
            <span class="hljs-keyword">this</span>.annotations = annotations;
            <span class="hljs-keyword">this</span>.declaredAnnotations = declaredAnnotations;
            <span class="hljs-keyword">this</span>.redefinedCount = redefinedCount;
        }
    }

    <span class="hljs-comment">// Annotations cache</span>
    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">&quot;UnusedDeclaration&quot;</span>)
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">transient</span> AnnotationData annotationData;

    <span class="hljs-function"><span class="hljs-keyword">private</span> AnnotationData <span class="hljs-title">annotationData</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) { <span class="hljs-comment">// retry loop</span>
            AnnotationData annotationData = <span class="hljs-keyword">this</span>.annotationData;
            <span class="hljs-keyword">int</span> classRedefinedCount = <span class="hljs-keyword">this</span>.classRedefinedCount;
            <span class="hljs-keyword">if</span> (annotationData != <span class="hljs-keyword">null</span> &amp;&amp;
                annotationData.redefinedCount == classRedefinedCount) {
                <span class="hljs-keyword">return</span> annotationData;
            }
            <span class="hljs-comment">// null or stale annotationData -&gt; optimistically create new instance</span>
            AnnotationData newAnnotationData = createAnnotationData(classRedefinedCount);
            <span class="hljs-comment">// try to install it</span>
            <span class="hljs-keyword">if</span> (Atomic.casAnnotationData(<span class="hljs-keyword">this</span>, annotationData, newAnnotationData)) {
                <span class="hljs-comment">// successfully installed new AnnotationData</span>
                <span class="hljs-keyword">return</span> newAnnotationData;
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> AnnotationData <span class="hljs-title">createAnnotationData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> classRedefinedCount)</span> </span>{
        Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations =
            AnnotationParser.parseAnnotations(getRawAnnotations(), getConstantPool(), <span class="hljs-keyword">this</span>);
        Class&lt;?&gt; superClass = getSuperclass();
        Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">if</span> (superClass != <span class="hljs-keyword">null</span>) {
            Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; superAnnotations =
                superClass.annotationData().annotations;
            <span class="hljs-keyword">for</span> (Map.Entry&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; e : superAnnotations.entrySet()) {
                Class&lt;? extends Annotation&gt; annotationClass = e.getKey();
                <span class="hljs-keyword">if</span> (AnnotationType.getInstance(annotationClass).isInherited()) {
                    <span class="hljs-keyword">if</span> (annotations == <span class="hljs-keyword">null</span>) { <span class="hljs-comment">// lazy construction</span>
                        annotations = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;((Math.max(
                                declaredAnnotations.size(),
                                Math.min(<span class="hljs-number">12</span>, declaredAnnotations.size() + superAnnotations.size())
                            ) * <span class="hljs-number">4</span> + <span class="hljs-number">2</span>) / <span class="hljs-number">3</span>
                        );
                    }
                    annotations.put(annotationClass, e.getValue());
                }
            }
        }
        <span class="hljs-keyword">if</span> (annotations == <span class="hljs-keyword">null</span>) {
            <span class="hljs-comment">// no inherited annotations -&gt; share the Map with declaredAnnotations</span>
            annotations = declaredAnnotations;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// at least one inherited annotation -&gt; declared may override inherited</span>
            annotations.putAll(declaredAnnotations);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnnotationData(annotations, declaredAnnotations, classRedefinedCount);
    }

    <span class="hljs-comment">// Annotation types cache their internal (AnnotationType) form</span>

    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">&quot;UnusedDeclaration&quot;</span>)
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">transient</span> AnnotationType annotationType;

    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">casAnnotationType</span><span class="hljs-params">(AnnotationType oldType, AnnotationType newType)</span> </span>{
        <span class="hljs-keyword">return</span> Atomic.casAnnotationType(<span class="hljs-keyword">this</span>, oldType, newType);
    }

    <span class="hljs-function">AnnotationType <span class="hljs-title">getAnnotationType</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> annotationType;
    }

    Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; getDeclaredAnnotationMap() {
        <span class="hljs-keyword">return</span> annotationData().declaredAnnotations;
    }

    <span class="hljs-comment">/* Backing store of user-defined values pertaining to this class.
     * Maintained by the ClassValue class.
     */</span>
    <span class="hljs-keyword">transient</span> ClassValue.ClassValueMap classValueMap;

    <span class="hljs-comment">/**
     * Returns an {<span class="hljs-doctag">@code</span> AnnotatedType} object that represents the use of a
     * type to specify the superclass of the entity represented by this {<span class="hljs-doctag">@code</span>
     * Class} object. (The &lt;em&gt;use&lt;/em&gt; of type Foo to specify the superclass
     * in &apos;...  extends Foo&apos; is distinct from the &lt;em&gt;declaration&lt;/em&gt; of type
     * Foo.)
     *
     * &lt;p&gt; If this {<span class="hljs-doctag">@code</span> Class} object represents a type whose declaration
     * does not explicitly indicate an annotated superclass, then the return
     * value is an {<span class="hljs-doctag">@code</span> AnnotatedType} object representing an element with no
     * annotations.
     *
     * &lt;p&gt; If this {<span class="hljs-doctag">@code</span> Class} represents either the {<span class="hljs-doctag">@code</span> Object} class, an
     * interface type, an array type, a primitive type, or void, the return
     * value is {<span class="hljs-doctag">@code</span> null}.
     *
     * <span class="hljs-doctag">@return</span> an object representing the superclass
     * <span class="hljs-doctag">@since</span> 1.8
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> AnnotatedType <span class="hljs-title">getAnnotatedSuperclass</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == Object.class ||
                isInterface() ||
                isArray() ||
                isPrimitive() ||
                <span class="hljs-keyword">this</span> == Void.TYPE) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        }

        <span class="hljs-keyword">return</span> TypeAnnotationParser.buildAnnotatedSuperclass(getRawTypeAnnotations(), getConstantPool(), <span class="hljs-keyword">this</span>);
    }

    <span class="hljs-comment">/**
     * Returns an array of {<span class="hljs-doctag">@code</span> AnnotatedType} objects that represent the use
     * of types to specify superinterfaces of the entity represented by this
     * {<span class="hljs-doctag">@code</span> Class} object. (The &lt;em&gt;use&lt;/em&gt; of type Foo to specify a
     * superinterface in &apos;... implements Foo&apos; is distinct from the
     * &lt;em&gt;declaration&lt;/em&gt; of type Foo.)
     *
     * &lt;p&gt; If this {<span class="hljs-doctag">@code</span> Class} object represents a class, the return value is
     * an array containing objects representing the uses of interface types to
     * specify interfaces implemented by the class. The order of the objects in
     * the array corresponds to the order of the interface types used in the
     * &apos;implements&apos; clause of the declaration of this {<span class="hljs-doctag">@code</span> Class} object.
     *
     * &lt;p&gt; If this {<span class="hljs-doctag">@code</span> Class} object represents an interface, the return
     * value is an array containing objects representing the uses of interface
     * types to specify interfaces directly extended by the interface. The
     * order of the objects in the array corresponds to the order of the
     * interface types used in the &apos;extends&apos; clause of the declaration of this
     * {<span class="hljs-doctag">@code</span> Class} object.
     *
     * &lt;p&gt; If this {<span class="hljs-doctag">@code</span> Class} object represents a class or interface whose
     * declaration does not explicitly indicate any annotated superinterfaces,
     * the return value is an array of length 0.
     *
     * &lt;p&gt; If this {<span class="hljs-doctag">@code</span> Class} object represents either the {<span class="hljs-doctag">@code</span> Object}
     * class, an array type, a primitive type, or void, the return value is an
     * array of length 0.
     *
     * <span class="hljs-doctag">@return</span> an array representing the superinterfaces
     * <span class="hljs-doctag">@since</span> 1.8
     */</span>
    <span class="hljs-keyword">public</span> AnnotatedType[] getAnnotatedInterfaces() {
         <span class="hljs-keyword">return</span> TypeAnnotationParser.buildAnnotatedInterfaces(getRawTypeAnnotations(), getConstantPool(), <span class="hljs-keyword">this</span>);
    }
}
</code></pre>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="Package.html" class="navigation navigation-prev " aria-label="Previous page: Package">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="ClassLoader.html" class="navigation navigation-next " aria-label="Next page: ClassLoader">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Class","level":"1.2.1.31","depth":3,"next":{"title":"ClassLoader","level":"1.2.1.32","depth":3,"path":"src/java/lang/ClassLoader.md","ref":"src/java/lang/ClassLoader.md","articles":[]},"previous":{"title":"Package","level":"1.2.1.30","depth":3,"path":"src/java/lang/Package.md","ref":"src/java/lang/Package.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["livereload"],"pluginsConfig":{"livereload":{},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"src/java/lang/Class.md","mtime":"2019-09-12T03:18:12.259Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2019-09-12T03:30:06.914Z"},"basePath":"../../..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../../../gitbook/gitbook.js"></script>
    <script src="../../../gitbook/theme.js"></script>
    
        
        <script src="../../../gitbook/gitbook-plugin-livereload/plugin.js"></script>
        
    
        
        <script src="../../../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../../../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../../../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../../../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../../../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

